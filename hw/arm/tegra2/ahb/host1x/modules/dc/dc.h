/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_DC_H
#define TEGRA_DC_H

#define CMD_GENERAL_INCR_SYNCPT_OFFSET 0x0
#define CMD_GENERAL_INCR_SYNCPT_RESET  0x00000000
typedef union cmd_general_incr_syncpt_u {
    struct {
        unsigned int general_indx:8;        /* syncpt index value */
        unsigned int general_cond:8;        /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = HSPI 5 = FRAME_DONE 6 = VPULSE3 7 = FRAME_START 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} cmd_general_incr_syncpt_t;

#define CMD_GENERAL_INCR_SYNCPT_CNTRL_OFFSET 0x1
#define CMD_GENERAL_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union cmd_general_incr_syncpt_cntrl_u {
    struct {
        unsigned int general_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int general_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_general_incr_syncpt_cntrl_t;

#define CMD_GENERAL_INCR_SYNCPT_ERROR_OFFSET 0x2
#define CMD_GENERAL_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union cmd_general_incr_syncpt_error_u {
    struct {
        unsigned int general_cond_status:32;/* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    uint32_t reg32;
} cmd_general_incr_syncpt_error_t;

#define CMD_WIN_A_INCR_SYNCPT_OFFSET 0x8
#define CMD_WIN_A_INCR_SYNCPT_RESET  0x00000000
typedef union cmd_win_a_incr_syncpt_u {
    struct {
        unsigned int win_a_indx:8;          /* syncpt index value */
        unsigned int win_a_cond:8;          /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} cmd_win_a_incr_syncpt_t;

#define CMD_WIN_A_INCR_SYNCPT_CNTRL_OFFSET 0x9
#define CMD_WIN_A_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union cmd_win_a_incr_syncpt_cntrl_u {
    struct {
        unsigned int win_a_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int win_a_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_win_a_incr_syncpt_cntrl_t;

#define CMD_WIN_A_INCR_SYNCPT_ERROR_OFFSET 0xA
#define CMD_WIN_A_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union cmd_win_a_incr_syncpt_error_u {
    struct {
        unsigned int win_a_cond_status:32;  /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    uint32_t reg32;
} cmd_win_a_incr_syncpt_error_t;

#define CMD_WIN_B_INCR_SYNCPT_OFFSET 0x10
#define CMD_WIN_B_INCR_SYNCPT_RESET  0x00000000
typedef union cmd_win_b_incr_syncpt_u {
    struct {
        unsigned int win_b_indx:8;          /* syncpt index value */
        unsigned int win_b_cond:8;          /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} cmd_win_b_incr_syncpt_t;

#define CMD_WIN_B_INCR_SYNCPT_CNTRL_OFFSET 0x11
#define CMD_WIN_B_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union cmd_win_b_incr_syncpt_cntrl_u {
    struct {
        unsigned int win_b_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int win_b_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_win_b_incr_syncpt_cntrl_t;

#define CMD_WIN_B_INCR_SYNCPT_ERROR_OFFSET 0x12
#define CMD_WIN_B_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union cmd_win_b_incr_syncpt_error_u {
    struct {
        unsigned int win_b_cond_status:32;  /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    uint32_t reg32;
} cmd_win_b_incr_syncpt_error_t;

#define CMD_WIN_C_INCR_SYNCPT_OFFSET 0x18
#define CMD_WIN_C_INCR_SYNCPT_RESET  0x00000000
typedef union cmd_win_c_incr_syncpt_u {
    struct {
        unsigned int win_c_indx:8;          /* syncpt index value */
        unsigned int win_c_cond:8;          /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} cmd_win_c_incr_syncpt_t;

#define CMD_WIN_C_INCR_SYNCPT_CNTRL_OFFSET 0x19
#define CMD_WIN_C_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union cmd_win_c_incr_syncpt_cntrl_u {
    struct {
        unsigned int win_c_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int win_c_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_win_c_incr_syncpt_cntrl_t;

#define CMD_WIN_C_INCR_SYNCPT_ERROR_OFFSET 0x1A
#define CMD_WIN_C_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union cmd_win_c_incr_syncpt_error_u {
    struct {
        unsigned int win_c_cond_status:32;  /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    uint32_t reg32;
} cmd_win_c_incr_syncpt_error_t;

#define CMD_CONT_SYNCPT_VSYNC_OFFSET 0x28
#define CMD_CONT_SYNCPT_VSYNC_RESET  0x00000000
typedef union cmd_cont_syncpt_vsync_u {
    struct {
        unsigned int vsync_indx:8;          /* return INDX (set HOST_CLRD packet TYPE field to SYNCPT) */
        unsigned int vsync_en:1;            /* on host read bus every time VSYNC (V-blank leading edge) happens and VSYNC_EN is set 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_cont_syncpt_vsync_t;

#define CMD_CTXSW_OFFSET 0x30
#define CMD_CTXSW_RESET  0x0000F800
typedef union cmd_ctxsw_u {
    struct {
        unsigned int curr_class:10;         /* Current working class */
        unsigned int undefined_bit_10:1;
        unsigned int auto_ack:1;            /* Automatically acknowledge any incoming context switch requests 0 = MANUAL 1 = AUTOACK */
        unsigned int curr_channel:4;        /* Current working channel, reset to 'invalid' */
        unsigned int next_class:10;         /* Next requested class */
        unsigned int undefined_bits_26_27:2;
        unsigned int next_channel:4;        /* Next requested channel */
    };

    uint32_t reg32;
} cmd_ctxsw_t;

#define CMD_DISPLAY_COMMAND_OPTION0_OFFSET 0x31
#define CMD_DISPLAY_COMMAND_OPTION0_RESET  0x00000000
typedef union cmd_display_command_option0_u {
    struct {
        unsigned int msf_polarity:1;        /* Main-Display Stop Frame (MSF) Polarity; 0= Active high; 1= Active low */
        unsigned int msf_enable:1;          /* Main-Display Stop Frame (MSF) input This is effective only in Non-Continuous Display mode 0= Disabled 1= Enabled When enabled, MSF signal can be input through LSPI pin. When MSF is enabled a trigger to send a frame in Non-Continuous Display mode will be delayed until MSF is active. 0 = DISABLE 1 = ENABLE */
        unsigned int msf_source:2;          /* Source pin for the MSF input Controls which pin will be used as the source for the trigger input when MSF mode is enabled. Note that although the same pins are available for both MSF and SSF, the order in the enum and hence the values differ between the pins. This is to maintain backwards compatibility with previous chips, which had a fixed mapping. The init value and the first value in the enum reflects this historical mapping. 0= LCD_SPI pin (legacy default) 1= LCD_DC pin 2= LCD_SDI pin 3= RESERVED for future use. 0 = MSF_LSPI 1 = MSF_LDC 2 = MSF_LSDI */
        unsigned int ssf_polarity:1;        /* Sub-Display Stop Frame (SSF) Polarity; 0= Active high; 1= Active low */
        unsigned int ssf_enable:1;          /* Sub-Display Stop Frame (SSF) input This is effective only in Non-Continuous Display mode 0= Disabled 1= Enabled When enabled, SSF signal can be input through LDC pin. When SSF is enabled a trigger to send a frame in Non-Continuous Display mode will be delayed until SSF is active. 0 = DISABLE 1 = ENABLE */
        unsigned int ssf_source:2;          /* Source pin for the SSF input Controls which pin will be used as the source for the trigger input when MSF mode is enabled. Note that although the same pins are available for both MSF and SSF, the order in the enum and hence the values differ between the pins. This is to maintain backwards compatibility with previous chips, which had a fixed mapping. The init value and the first value in the enum reflects this historical mapping. 0= LCD_DC pin (legacy default) 1= LCD_SPI pin 2= LCD_SDI pin 3= RESERVED for future use. 0 = SSF_LDC 1 = SSF_LSPI 2 = SSF_LSDI */
        unsigned int undefined_bits_8_15:8;
        unsigned int window_a_nc_display:1; /* Window A Non-Continuous Display This is effective only in Non-Continuous Display mode when window A buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window A buffer is switched.  0 = DISABLE 1 = ENABLE */
        unsigned int window_b_nc_display:1; /* Window B Non-Continuous Display This is effective only in Non-Continuous Display mode when window B buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window B buffer is switched.  0 = DISABLE 1 = ENABLE */
        unsigned int window_c_nc_display:1; /* Window C Non-Continuous Display This is effective only in Non-Continuous Display mode when window B buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window B buffer is switched; 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} cmd_display_command_option0_t;

#define CMD_DISPLAY_COMMAND_OFFSET 0x32
#define CMD_DISPLAY_COMMAND_RESET  0x00000000
typedef union cmd_display_command_u {
    struct {
        unsigned int disp_command_raise:1;  /* Display Command Raise. Raise vector will be returned at the end of command completion 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_1_4:4;
        unsigned int display_ctrl_mode:2;   /* Display Controller Mode 0= Stop Display, this can be used to stop sending frame at the next frame boundary. This is automatically generated in Non-Continuous Display after sending one frame. If this is issued when display controller is already stopped then there is no frame sent. Raise vector (if raise is enabled) is also returned immediately. This command can also be used in non-continuous display mode to stop accepting non-host trigger conditions from other clients; 1= Continuous Display, the display controller will continuously send frame. Continuous display mode can be stopped by switching to Non-Continuous Display or by issuing Stop Display.; 2= Non-Continuous Display, the display controller is forced to send one frame of each active display and then wait for the next time this command is issued or for other (non-host) trigger conditions to send frame. The sending of frames may be delayed by MSF or SSF input signals from the display device. If a Stop 
Display is issued while in non-continuous display mode then non-host trigger conditions will no longer be accepted until the next time Non-Continuous Display is issued 0 = STOP 1 = C_DISPLAY 2 = NC_DISPLAY */
        unsigned int undefined_bits_7_21:15;
        unsigned int disp_command_raise_vector:5;/* Display Command Raise Vector This raise vector is at the next line or frame boundary, depending on GENERAL_ACT_CNTR_SEL */
        unsigned int disp_command_raise_channel_id:4;/* Display Command Channel ID */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} cmd_display_command_t;

#define CMD_SIGNAL_RAISE_OFFSET 0x33
#define CMD_SIGNAL_RAISE_RESET  0x00000000
typedef union cmd_signal_raise_u {
    struct {
        unsigned int signal_raise_vector:5; /* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise_select:3; /* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise_type:1;   /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE_SELECT=NONE or SIGNAL_RAISE_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} cmd_signal_raise_t;

#define CMD_DISPLAY_POWER_CONTROL_OFFSET 0x36
#define CMD_DISPLAY_POWER_CONTROL_RESET  0x00000000
typedef union cmd_display_power_control_u {
    struct {
        unsigned int pw0_enable:1;          /* PW0 signal Enable. This signal controls the display H and V counters. It must be enabled first and disabled last during display power sequencing. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int pw1_enable:1;          /* PW1 signal Enable. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int pw2_enable:1;          /* PW2 signal Enable. This signal controls pixel data processing. It should be enabled during V blank time. This signal also controls the time when pin polarity takes effect at the pad. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_5:1;
        unsigned int pw3_enable:1;          /* PW3 signal Enable. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int pw4_enable:1;          /* PW4 signal Enable. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_9_15:7;
        unsigned int pm0_enable:1;          /* PM0 signal Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int pm1_enable:1;          /* PM1 signal Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int spi_enable:1;          /* SPI interface Enable. This enables clock to SPI interface logic for Host SPI, IS SPI, and LCD SPI. 0 = DISABLE 1 = ENABLE */
        unsigned int hspi_enable:1;         /* Host SPI write cycle Enable. SPI_ENABLE must be enabled also for this bit to be effective. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} cmd_display_power_control_t;

#define CMD_INT_STATUS_OFFSET 0x37
#define CMD_INT_STATUS_RESET  0x00000000
typedef union cmd_int_status_u {
    struct {
        unsigned int ctxsw_int:1;           /* Context Switch Interrupt Status (this is cleared on write); 0= interrupt not pending; 1= interrupt pending */
        unsigned int frame_end_int:1;       /* Frame End Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int v_blank_int:1;         /* Vertical Blank Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int h_blank_int:1;         /* Horizontal Blank Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int v_pulse3_int:1;        /* Vertical Pulse 3 Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int:1;        /* SPI Busy Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_a_uf_int:1;        /* Window A Underflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_b_uf_int:1;        /* Window B Underflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_c_uf_int:1;        /* Window C Underflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int epp_of_int:1;          /* Display2epp Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int msf_int:1;             /* Main-Display Stop Frame Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int ssf_int:1;             /* Sub-Display Stop Frame Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_a_of_int:1;        /* Window A Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_b_of_int:1;        /* Window B Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_c_of_int:1;        /* Window C Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int:1;          /* GPIO 0 Interrupt Status, connected to LCD_PWR0; 0= interrupt not pending; 1= interrupt pending */
        unsigned int gpio_1_int:1;          /* GPIO 1 Interrupt Status, connected to LCD_PWR1; 0= interrupt not pending; 1= interrupt pending */
        unsigned int gpio_2_int:1;          /* GPIO 2 Interrupt Status, connected to LCD_PWR2; 0= interrupt not pending; 1= interrupt pending */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_status_t;

#define CMD_INT_MASK_OFFSET 0x38
#define CMD_INT_MASK_RESET  0x00000000
typedef union cmd_int_mask_u {
    struct {
        unsigned int ctxsw_int_mask:1;      /* Context Switch Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int frame_end_int_mask:1;  /* Frame End Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int v_blank_int_mask:1;    /* Vertical Blank Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int h_blank_int_mask:1;    /* Horizontal Blank Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int v_pulse3_int_mask:1;   /* Vertical Pulse 3 Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_mask:1;   /* SPI Busy Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_a_uf_int_mask:1;   /* Window A Underflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_b_uf_int_mask:1;   /* Window B Underflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_c_uf_int_mask:1;   /* Window C Underflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_mask:1;        /* Main-Display Stop Frame Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ssf_int_mask:1;        /* Sub-Display Stop Frame Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_a_of_int_mask:1;   /* Window A Overflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_b_of_int_mask:1;   /* Window B Overflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_c_of_int_mask:1;   /* Window C Overflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_mask:1;     /* GPIO 0 Interrupt Mask, connected to LCD_PWR0 0= interrupt masked 1= interrupt not masked 0 = MASKED 1 = NOTMASKED */
        unsigned int gpio_1_int_mask:1;     /* GPIO 1 Interrupt Mask, connected to LCD_PWR1  0 = MASKED 1 = NOTMASKED */
        unsigned int gpio_2_int_mask:1;     /* GPIO 2 Interrupt Mask, connected to LCD_PWR2  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_mask_t;

#define CMD_INT_ENABLE_OFFSET 0x39
#define CMD_INT_ENABLE_RESET  0x00000001
typedef union cmd_int_enable_u {
    struct {
        unsigned int ctxsw_int_enable:1;    /* Context Switch Interrupt Enable 0= interrupt disabled 1= interrupt enabled 0 = DISABLE 1 = ENABLE */
        unsigned int frame_end_int_enable:1;/* Frame End Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int v_blank_int_enable:1;  /* Vertical Blank Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int h_blank_int_enable:1;  /* Horizontal Blank Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int v_pulse3_int_enable:1; /* Vertical Pulse 3 Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_enable:1; /* SPI Busy Interrupt Enable; 0 = DISABLE 1 = ENABLE */
        unsigned int win_a_uf_int_enable:1; /* Window A Underflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_b_uf_int_enable:1; /* Window B Underflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_c_uf_int_enable:1; /* Window C Underflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_enable:1;      /* Main-Display Stop Frame Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int ssf_int_enable:1;      /* Sub-Display Stop Frame Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_a_of_int_enable:1; /* Window A Overflow Interrupt Enable; 0 = DISABLE 1 = ENABLE */
        unsigned int win_b_of_int_enable:1; /* Window B Overflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_c_of_int_enable:1; /* Window C Overflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_enable:1;   /* Display GPIO_0 Interrupt Enable, connected to LCD_PWR0; 0 = DISABLE 1 = ENABLE */
        unsigned int gpio_1_int_enable:1;   /* Display GPIO_1 Interrupt Enable, connected to LCD_PWR1  0 = DISABLE 1 = ENABLE */
        unsigned int gpio_2_int_enable:1;   /* Display GPIO_2 Interrupt Enable, connected to LCD_PWR2  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_enable_t;

#define CMD_INT_TYPE_OFFSET 0x3A
#define CMD_INT_TYPE_RESET  0x00000000
typedef union cmd_int_type_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int frame_end_int_type:1;  /* Frame End Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int v_blank_int_type:1;    /* Vertical Blank Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int h_blank_int_type:1;    /* Horizontal Blank Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int v_pulse3_int_type:1;   /* Vertical Pulse 3 Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_type:1;   /* SPI Busy Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_a_uf_int_type:1;   /* Window A Underflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_b_uf_int_type:1;   /* Window B Underflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_c_uf_int_type:1;   /* Window C Underflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_type:1;        /* Main-Display Stop Frame Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int ssf_int_type:1;        /* Sub-Display Stop Frame Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_a_of_int_type:1;   /* Window A Overflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_b_of_int_type:1;   /* Window B Overflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_c_of_int_type:1;   /* Window C Overflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_type:1;     /* Display GPIO_0 Interrupt Type, connected to LCD_PWR0  0 = EDGE 1 = LEVEL */
        unsigned int gpio_1_int_type:1;     /* Display GPIO_1 Interrupt Type, connected to LCD_PWR1  0 = EDGE 1 = LEVEL */
        unsigned int gpio_2_int_type:1;     /* Display GPIO_2 Interrupt Type, connected to LCD_PWR2  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_type_t;

#define CMD_INT_POLARITY_OFFSET 0x3B
#define CMD_INT_POLARITY_RESET  0x00000000
typedef union cmd_int_polarity_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int frame_end_int_polarity:1;/* Frame End. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int v_blank_int_polarity:1;/* V Blank. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int h_blank_int_polarity:1;/* H Blank. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int v_pulse3_int_polarity:1;/* V Pulse 3. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_polarity:1;/* SPI Busy. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_a_uf_int_polarity:1;/* Window A Underflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_b_uf_int_polarity:1;/* Window B Underflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_c_uf_int_polarity:1;/* Window C Underflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_polarity:1;    /* Main-Display Stop Frame. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int ssf_int_polarity:1;    /* Sub-Display Stop Frame. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_a_of_int_polarity:1;/* Window A Overflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_b_of_int_polarity:1;/* Window B Overflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_c_of_int_polarity:1;/* Window C Overflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_polarity:1; /* Display GPIO_0 Interrupt. Interrupt Polarity, connected to LCD_PWR0 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int gpio_1_int_polarity:1; /* Display GPIO_1 Interrupt. Interrupt Polarity, connected to LCD_PWR1 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int gpio_2_int_polarity:1; /* Display GPIO_2 Interrupt. Interrupt Polarity, connected to LCD_PWR2 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_polarity_t;

#define CMD_SIGNAL_RAISE1_OFFSET 0x3C
#define CMD_SIGNAL_RAISE1_RESET  0x00000000
typedef union cmd_signal_raise1_u {
    struct {
        unsigned int signal_raise1_vector:5;/* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise1_select:3;/* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise1_type:1;  /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE1_SELECT=NONE or SIGNAL_RAISE1_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise1_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} cmd_signal_raise1_t;

#define CMD_SIGNAL_RAISE2_OFFSET 0x3D
#define CMD_SIGNAL_RAISE2_RESET  0x00000000
typedef union cmd_signal_raise2_u {
    struct {
        unsigned int signal_raise2_vector:5;/* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise2_select:3;/* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise2_type:1;  /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE2_SELECT=NONE or SIGNAL_RAISE2_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise2_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} cmd_signal_raise2_t;

#define CMD_SIGNAL_RAISE3_OFFSET 0x3E
#define CMD_SIGNAL_RAISE3_RESET  0x00000000
typedef union cmd_signal_raise3_u {
    struct {
        unsigned int signal_raise3_vector:5;/* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise3_select:3;/* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise3_type:1;  /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE3_SELECT=NONE or SIGNAL_RAISE3_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise3_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} cmd_signal_raise3_t;

#define CMD_STATE_ACCESS_OFFSET 0x40
#define CMD_STATE_ACCESS_RESET  0x00000000
typedef union cmd_state_access_u {
    struct {
        unsigned int read_mux:1;            /* Read access control 0= read assembly state 1= read active state Arm state register read is not controlled by this mux, but by reading the registers with "_NS" suffix 0 = ASSEMBLY 1 = ACTIVE */
        unsigned int undefined_bit_1:1;
        unsigned int write_mux:1;           /* Write access control 0= write assembly state 1= write active state When set to ACTIVE, register writes also propagate to assembly set for double buffered registers, to both assembly and arm set for triple buffered registers. 0 = ASSEMBLY 1 = ACTIVE */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} cmd_state_access_t;

#define CMD_STATE_CONTROL_OFFSET 0x41
#define CMD_STATE_CONTROL_RESET  0x00000000
typedef union cmd_state_control_u {
    struct {
        unsigned int general_act_req:1;     /* Non-window-specific 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int win_a_act_req:1;       /* Window A activation request 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int win_b_act_req:1;       /* Window B activation request 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int win_c_act_req:1;       /* Window C activation request 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_7:4;
        unsigned int general_update:1;      /* Trigger for arming state (from assembly to armed state) for a subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int win_a_update:1;        /* Trigger for arming state (from assembly to armed state) for the win A subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int win_b_update:1;        /* Trigger for arming state (from assembly to armed state) for the win B subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int win_c_update:1;        /* Trigger for arming state (from assembly to armed state) for the win C subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_12_23:12;
        unsigned int nc_host_trig_enable:1; /* Host trigger enable. Effective only in Non-continuous mode. The exception is that when TVO is enabled, this trigger is ignored so as not to corrupt TV output. Note that when this field is enabled, GENERAL_ACT_REQ must be enabled at the same time. 0= disable: no frame is triggered  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_25_31:7;
    };

    uint32_t reg32;
} cmd_state_control_t;

#define CMD_DISPLAY_WINDOW_HEADER_OFFSET 0x42
#define CMD_DISPLAY_WINDOW_HEADER_RESET  0x00000000
typedef union cmd_display_window_header_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int window_a_select:1;     /* Window A Select 0= disable window A programming 1= enable window A programming 0 = DISABLE 1 = ENABLE */
        unsigned int window_b_select:1;     /* Window B Select 0= disable window B programming 1= enable window B programming 0 = DISABLE 1 = ENABLE */
        unsigned int window_c_select:1;     /* Window C Select 0= disable window C programming 1= enable window C programming 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} cmd_display_window_header_t;

#define CMD_REG_ACT_CONTROL_OFFSET 0x43
#define CMD_REG_ACT_CONTROL_RESET  0x00000000
typedef union cmd_reg_act_control_u {
    struct {
        unsigned int general_act_cntr_sel:1;/* Select which counter to use for general activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bit_1:1;
        unsigned int win_a_act_cntr_sel:1;  /* Select which counter to use for window A activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bit_3:1;
        unsigned int win_b_act_cntr_sel:1;  /* Select which counter to use for window B activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bit_5:1;
        unsigned int win_c_act_cntr_sel:1;  /* Select which counter to use for window C activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} cmd_reg_act_control_t;

#define COM_CRC_CONTROL_OFFSET 0x300
#define COM_CRC_CONTROL_RESET  0x00000000
typedef union com_crc_control_u {
    struct {
        unsigned int crc_enable:1;          /* CRC Enable  0 = DISABLE 1 = ENABLE */
        unsigned int crc_wait:1;            /* CRC Wait 0= 1 Vsync 1= 2 Vsync */
        unsigned int crc_input_data:1;      /* CRC input data 0= Full frame (RGB data and control) 1= Active display (Only RGB data)  0 = FULL_FRAME 1 = ACTIVE_DATA */
        unsigned int crc_always:1;          /* CRC always: calculate CRC for every following frames Must use with CRC_INPUT_DATA = ACTIVE_DATA if enabled, CRC_WAIT field is ignored.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} com_crc_control_t;

#define COM_CRC_CHECKSUM_OFFSET 0x301
#define COM_CRC_CHECKSUM_RESET  0x00000000
typedef union com_crc_checksum_u {
    struct {
        unsigned int crc_checksum:32;       /* CRC Checksum */
    };

    uint32_t reg32;
} com_crc_checksum_t;

#define COM_PIN_OUTPUT_ENABLE0_OFFSET 0x302
#define COM_PIN_OUTPUT_ENABLE0_RESET  0x00000000
typedef union com_pin_output_enable0_u {
    struct {
        unsigned int ld0_output_enable:1;   /* LD0 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld1_output_enable:1;   /* LD1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_3:1;
        unsigned int ld2_output_enable:1;   /* LD2 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_5:1;
        unsigned int ld3_output_enable:1;   /* LD3 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_7:1;
        unsigned int ld4_output_enable:1;   /* LD4 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_9:1;
        unsigned int ld5_output_enable:1;   /* LD5 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_11:1;
        unsigned int ld6_output_enable:1;   /* LD6 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_13:1;
        unsigned int ld7_output_enable:1;   /* LD7 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_15:1;
        unsigned int ld8_output_enable:1;   /* LD8 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_17:1;
        unsigned int ld9_output_enable:1;   /* LD9 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ld10_output_enable:1;  /* LD10 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_21:1;
        unsigned int ld11_output_enable:1;  /* LD11 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_23:1;
        unsigned int ld12_output_enable:1;  /* LD12 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_25:1;
        unsigned int ld13_output_enable:1;  /* LD13 pin output enable; 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_27:1;
        unsigned int ld14_output_enable:1;  /* LD14 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_29:1;
        unsigned int ld15_output_enable:1;  /* LD15 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_enable0_t;

#define COM_PIN_OUTPUT_ENABLE1_OFFSET 0x303
#define COM_PIN_OUTPUT_ENABLE1_RESET  0x00000000
typedef union com_pin_output_enable1_u {
    struct {
        unsigned int ld16_output_enable:1;  /* LD16 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld17_output_enable:1;  /* LD17 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_3_15:13;
        unsigned int lpw0_output_enable:1;  /* LCD_PWR0 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lpw1_output_enable:1;  /* LCD_PWR1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_19:1;
        unsigned int lpw2_output_enable:1;  /* LCD_PWR2 pin output enable; 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_21_23:3;
        unsigned int lsc0_output_enable:1;  /* LCD_PCLK pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_25:1;
        unsigned int lsc1_output_enable:1;  /* LCD_WR_N pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_27:1;
        unsigned int lvs_output_enable:1;   /* LVS pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_29:1;
        unsigned int lhs_output_enable:1;   /* LCD_HSYNC pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_enable1_t;

#define COM_PIN_OUTPUT_ENABLE2_OFFSET 0x304
#define COM_PIN_OUTPUT_ENABLE2_RESET  0x00510104
typedef union com_pin_output_enable2_u {
    struct {
        unsigned int lhp0_output_enable:1;  /* LCD_D21 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_1:1;
        unsigned int lhp1_output_enable:1;  /* LCD_D18 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_3:1;
        unsigned int lhp2_output_enable:1;  /* LCD_D19 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_5_7:3;
        unsigned int lvp0_output_enable:1;  /* LCD_DC1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_9:1;
        unsigned int lvp1_output_enable:1;  /* LCD_D20 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_11_15:5;
        unsigned int lm0_output_enable:1;   /* LCD_CS1_N pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lm1_output_enable:1;   /* LCD_M1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ldi_output_enable:1;   /* LCD_D22 pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_21:1;
        unsigned int lpp_output_enable:1;   /* LCD_D23 pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_output_enable2_t;

#define COM_PIN_OUTPUT_ENABLE3_OFFSET 0x305
#define COM_PIN_OUTPUT_ENABLE3_RESET  0x00000555
typedef union com_pin_output_enable3_u {
    struct {
        unsigned int lsck_output_enable:1;  /* LSCK pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_1:1;
        unsigned int lsda_output_enable:1;  /* LSDA pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_3:1;
        unsigned int lcsn_output_enable:1;  /* LCSN pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_5:1;
        unsigned int ldc_output_enable:1;   /* LDC pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_7:1;
        unsigned int lspi_output_enable:1;  /* LSPI pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_9:1;
        unsigned int lsdi_output_enable:1;  /* LSDI pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} com_pin_output_enable3_t;

#define COM_PIN_OUTPUT_POLARITY0_OFFSET 0x306
#define COM_PIN_OUTPUT_POLARITY0_RESET  0x00000000
typedef union com_pin_output_polarity0_u {
    struct {
        unsigned int ld0_output_polarity:1; /* LD0 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int ld1_output_polarity:1; /* LD1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_3:1;
        unsigned int ld2_output_polarity:1; /* LD2 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int ld3_output_polarity:1; /* LD3 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_7:1;
        unsigned int ld4_output_polarity:1; /* LD4 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_9:1;
        unsigned int ld5_output_polarity:1; /* LD5 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_11:1;
        unsigned int ld6_output_polarity:1; /* LD6 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_13:1;
        unsigned int ld7_output_polarity:1; /* LD7 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_15:1;
        unsigned int ld8_output_polarity:1; /* LD8 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_17:1;
        unsigned int ld9_output_polarity:1; /* LD9 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_19:1;
        unsigned int ld10_output_polarity:1;/* LD10 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_21:1;
        unsigned int ld11_output_polarity:1;/* LD11 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_23:1;
        unsigned int ld12_output_polarity:1;/* LD12 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_25:1;
        unsigned int ld13_output_polarity:1;/* LD13 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_27:1;
        unsigned int ld14_output_polarity:1;/* LD14 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_29:1;
        unsigned int ld15_output_polarity:1;/* LD15 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_polarity0_t;

#define COM_PIN_OUTPUT_POLARITY1_OFFSET 0x307
#define COM_PIN_OUTPUT_POLARITY1_RESET  0x00000000
typedef union com_pin_output_polarity1_u {
    struct {
        unsigned int ld16_output_polarity:1;/* LD16 pin output polarity; 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int ld17_output_polarity:1;/* LD17 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_3_15:13;
        unsigned int lpw0_output_polarity:1;/* LCD_PWR0 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_17:1;
        unsigned int lpw1_output_polarity:1;/* LCD_PWR1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_19:1;
        unsigned int lpw2_output_polarity:1;/* LCD_PWR2 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_21_23:3;
        unsigned int lsc0_output_polarity:1;/* LCD_PCLK pin output polarity. When used as PCLK (pixel clock), HIGH means that rising edge coincides with data transition, and LOW means that falling edge coincides with data transition. 0= active high 1= active low  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_25:1;
        unsigned int lsc1_output_polarity:1;/* LCD_WR_N pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_27:1;
        unsigned int lvs_output_polarity:1; /* LVS pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_29:1;
        unsigned int lhs_output_polarity:1; /* LCD_HSYNC pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_polarity1_t;

#define COM_PIN_OUTPUT_POLARITY2_OFFSET 0x308
#define COM_PIN_OUTPUT_POLARITY2_RESET  0x00000000
typedef union com_pin_output_polarity2_u {
    struct {
        unsigned int lhp0_output_polarity:1;/* LCD_D21 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int lhp1_output_polarity:1;/* LCD_D18 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_3:1;
        unsigned int lhp2_output_polarity:1;/* LCD_D19 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_5_7:3;
        unsigned int lvp0_output_polarity:1;/* LCD_DC1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_9:1;
        unsigned int lvp1_output_polarity:1;/* LCD_D20 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_11_15:5;
        unsigned int lm0_output_polarity:1; /* LCD_CS1_N pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_17:1;
        unsigned int lm1_output_polarity:1; /* LCD_M1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_19:1;
        unsigned int ldi_output_polarity:1; /* LCD_D22 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_21:1;
        unsigned int lpp_output_polarity:1; /* LCD_D23 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_output_polarity2_t;

#define COM_PIN_OUTPUT_POLARITY3_OFFSET 0x309
#define COM_PIN_OUTPUT_POLARITY3_RESET  0x00000000
typedef union com_pin_output_polarity3_u {
    struct {
        unsigned int lsck_output_polarity:1;/* LSCK pin output polarity; 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int lsda_output_polarity:1;/* LSDA pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_3:1;
        unsigned int lcsn_output_polarity:1;/* LCSN pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int ldc_output_polarity:1; /* LDC pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_7:1;
        unsigned int lspi_output_polarity:1;/* LSPI pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_9:1;
        unsigned int lsdi_output_polarity:1;/* LSDI pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} com_pin_output_polarity3_t;

#define COM_PIN_OUTPUT_DATA0_OFFSET 0x30A
#define COM_PIN_OUTPUT_DATA0_RESET  0x00000000
typedef union com_pin_output_data0_u {
    struct {
        unsigned int ld0_output_data:1;     /* LD0 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld0_output_data_mask:1;/* LD0 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld1_output_data:1;     /* LD1 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld1_output_data_mask:1;/* LD1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld2_output_data:1;     /* LD2 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld2_output_data_mask:1;/* LD2 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld3_output_data:1;     /* LD3 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld3_output_data_mask:1;/* LD3 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld4_output_data:1;     /* LD4 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld4_output_data_mask:1;/* LD4 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld5_output_data:1;     /* LD5 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld5_output_data_mask:1;/* LD5 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld6_output_data:1;     /* LD6 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld6_output_data_mask:1;/* LD6 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld7_output_data:1;     /* LD7 pin output data; 0 = LOW 1 = HIGH */
        unsigned int ld7_output_data_mask:1;/* LD7 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld8_output_data:1;     /* LD8 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld8_output_data_mask:1;/* LD8 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld9_output_data:1;     /* LD9 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld9_output_data_mask:1;/* LD9 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld10_output_data:1;    /* LD10 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld10_output_data_mask:1;/* LD10 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld11_output_data:1;    /* LD11 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld11_output_data_mask:1;/* LD11 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld12_output_data:1;    /* LD12 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld12_output_data_mask:1;/* LD12 pin output data  0 = MASKED 1 = NOTMASKED */
        unsigned int ld13_output_data:1;    /* LD13 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld13_output_data_mask:1;/* LD13 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld14_output_data:1;    /* LD14 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld14_output_data_mask:1;/* LD14 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld15_output_data:1;    /* LD15 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld15_output_data_mask:1;/* LD15 pin output data mask  0 = MASKED 1 = NOTMASKED */
    };

    uint32_t reg32;
} com_pin_output_data0_t;

#define COM_PIN_OUTPUT_DATA1_OFFSET 0x30B
#define COM_PIN_OUTPUT_DATA1_RESET  0x00000000
typedef union com_pin_output_data1_u {
    struct {
        unsigned int ld16_output_data:1;    /* LD16 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld16_output_data_mask:1;/* LD16 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld17_output_data:1;    /* LD17 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld17_output_data_mask:1;/* LD17 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_4_15:12;
        unsigned int lpw0_output_data:1;    /* LCD_PWR0 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpw0_output_data_mask:1;/* LCD_PWR0 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lpw1_output_data:1;    /* LCD_PWR1 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpw1_output_data_mask:1;/* LCD_PWR1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lpw2_output_data:1;    /* LCD_PWR2 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpw2_output_data_mask:1;/* LCD_PWR2 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_22_23:2;
        unsigned int lsc0_output_data:1;    /* LCD_PCLK pin output data  0 = LOW 1 = HIGH */
        unsigned int lsc0_output_data_mask:1;/* LCD_PCLK pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lsc1_output_data:1;    /* LCD_WR_N pin output data  0 = LOW 1 = HIGH */
        unsigned int lsc1_output_data_mask:1;/* LCD_WR_N pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lvs_output_data:1;     /* LVS pin output data  0 = LOW 1 = HIGH */
        unsigned int lvs_output_data_mask:1;/* LVS pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lhs_output_data:1;     /* LCD_HSYNC pin output data  0 = LOW 1 = HIGH */
        unsigned int lhs_output_data_mask:1;/* LCD_HSYNC pin output data mask  0 = MASKED 1 = NOTMASKED */
    };

    uint32_t reg32;
} com_pin_output_data1_t;

#define COM_PIN_OUTPUT_DATA2_OFFSET 0x30C
#define COM_PIN_OUTPUT_DATA2_RESET  0x00000000
typedef union com_pin_output_data2_u {
    struct {
        unsigned int lhp0_output_data:1;    /* LCD_D21 pin output data  0 = LOW 1 = HIGH */
        unsigned int lhp0_output_data_mask:1;/* LCD_D21 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lhp1_output_data:1;    /* LCD_D18 pin output data  0 = LOW 1 = HIGH */
        unsigned int lhp1_output_data_mask:1;/* LCD_D18 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lhp2_output_data:1;    /* LCD_D19 pin output data  0 = LOW 1 = HIGH */
        unsigned int lhp2_output_data_mask:1;/* LCD_D19 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_6_7:2;
        unsigned int lvp0_output_data:1;    /* LCD_DC1 pin output data  0 = LOW 1 = HIGH */
        unsigned int lvp0_output_data_mask:1;/* LCD_DC1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lvp1_output_data:1;    /* LCD_D20 pin output data  0 = LOW 1 = HIGH */
        unsigned int lvp1_output_data_mask:1;/* LCD_D20 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_12_15:4;
        unsigned int lm0_output_data:1;     /* LCD_CS1_N pin output data  0 = LOW 1 = HIGH */
        unsigned int lm0_output_data_mask:1;/* LCD_CS1_N pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lm1_output_data:1;     /* LCD_M1 pin output data  0 = LOW 1 = HIGH */
        unsigned int lm1_output_data_mask:1;/* LCD_M1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ldi_output_data:1;     /* LCD_D22 pin output data  0 = LOW 1 = HIGH */
        unsigned int ldi_output_data_mask:1;/* LCD_D22 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lpp_output_data:1;     /* LCD_D23 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpp_output_data_mask:1;/* LCD_D23 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} com_pin_output_data2_t;

#define COM_PIN_OUTPUT_DATA3_OFFSET 0x30D
#define COM_PIN_OUTPUT_DATA3_RESET  0x00000000
typedef union com_pin_output_data3_u {
    struct {
        unsigned int lsck_output_data:1;    /* LSCK pin output data  0 = LOW 1 = HIGH */
        unsigned int lsck_output_data_mask:1;/* LSCK pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lsda_output_data:1;    /* LSDA pin output data  0 = LOW 1 = HIGH */
        unsigned int lsda_output_data_mask:1;/* LSDA pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lcsn_output_data:1;    /* LCSN pin output data  0 = LOW 1 = HIGH */
        unsigned int lcsn_output_data_mask:1;/* LCSN pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ldc_output_data:1;     /* LDC pin output data  0 = LOW 1 = HIGH */
        unsigned int ldc_output_data_mask:1;/* LDC pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lspi_output_data:1;    /* LSPI pin output data  0 = LOW 1 = HIGH */
        unsigned int lspi_output_data_mask:1;/* LSPI pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lsdi_output_data:1;    /* LSDI pin output data  0 = LOW 1 = HIGH */
        unsigned int lsdi_output_data_mask:1;/* LSDI pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} com_pin_output_data3_t;

#define COM_PIN_INPUT_ENABLE0_OFFSET 0x30E
#define COM_PIN_INPUT_ENABLE0_RESET  0x00000000
typedef union com_pin_input_enable0_u {
    struct {
        unsigned int ld0_input_enable:1;    /* LD0 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld1_input_enable:1;    /* LD1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int ld2_input_enable:1;    /* LD2 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_5:1;
        unsigned int ld3_input_enable:1;    /* LD3 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int ld4_input_enable:1;    /* LD4 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int ld5_input_enable:1;    /* LD5 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int ld6_input_enable:1;    /* LD6 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_13:1;
        unsigned int ld7_input_enable:1;    /* LD7 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_15:1;
        unsigned int ld8_input_enable:1;    /* LD8 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int ld9_input_enable:1;    /* LD9 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ld10_input_enable:1;   /* LD10 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int ld11_input_enable:1;   /* LD11 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_23:1;
        unsigned int ld12_input_enable:1;   /* LD12 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_25:1;
        unsigned int ld13_input_enable:1;   /* LD13 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_27:1;
        unsigned int ld14_input_enable:1;   /* LD14 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int ld15_input_enable:1;   /* LD15 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_input_enable0_t;

#define COM_PIN_INPUT_ENABLE1_OFFSET 0x30F
#define COM_PIN_INPUT_ENABLE1_RESET  0x00000000
typedef union com_pin_input_enable1_u {
    struct {
        unsigned int ld16_input_enable:1;   /* LD16 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld17_input_enable:1;   /* LD17 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_15:13;
        unsigned int lpw0_input_enable:1;   /* LCD_PWR0 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lpw1_input_enable:1;   /* LCD_PWR1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int lpw2_input_enable:1;   /* LCD_PWR2 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_23:3;
        unsigned int lsc0_input_enable:1;   /* LCD_PCLK pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_25:1;
        unsigned int lsc1_input_enable:1;   /* LCD_WR_N pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_27:1;
        unsigned int lvs_input_enable:1;    /* LCD_VSYNC pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int lhs_input_enable:1;    /* LCD_HSYNC pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_input_enable1_t;

#define COM_PIN_INPUT_ENABLE2_OFFSET 0x310
#define COM_PIN_INPUT_ENABLE2_RESET  0x00000000
typedef union com_pin_input_enable2_u {
    struct {
        unsigned int lhp0_input_enable:1;   /* LCD_D21 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int lhp1_input_enable:1;   /* LCD_D18 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int lhp2_input_enable:1;   /* LCD_D19 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_5_7:3;
        unsigned int lvp0_input_enable:1;   /* LCD_DC1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int lvp1_input_enable:1;   /* LCD_D20 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_11_15:5;
        unsigned int lm0_input_enable:1;    /* LCD_CS1_N pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lm1_input_enable:1;    /* LCD_M1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ldi_input_enable:1;    /* LCD_D22 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int lpp_input_enable:1;    /* LCD_D23 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_input_enable2_t;

#define COM_PIN_INPUT_ENABLE3_OFFSET 0x311
#define COM_PIN_INPUT_ENABLE3_RESET  0x00000000
typedef union com_pin_input_enable3_u {
    struct {
        unsigned int lsck_input_enable:1;   /* LSCK pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int lsda_input_enable:1;   /* LSDA pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int lcsn_input_enable:1;   /* LCSN pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_5:1;
        unsigned int ldc_input_enable:1;    /* LDC pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int lspi_input_enable:1;   /* LSPI pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int lsdi_input_enable:1;   /* LSDI pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} com_pin_input_enable3_t;

#define COM_PIN_INPUT_DATA0_OFFSET 0x312
#define COM_PIN_INPUT_DATA0_RESET  0x00000000
typedef union com_pin_input_data0_u {
    struct {
        unsigned int ld0_input_data:1;      /* LD0 pin input data */
        unsigned int ld1_input_data:1;      /* LD1 pin input data */
        unsigned int ld2_input_data:1;      /* LD2 pin input data */
        unsigned int ld3_input_data:1;      /* LD3 pin input data */
        unsigned int ld4_input_data:1;      /* LD4 pin input data */
        unsigned int ld5_input_data:1;      /* LD5 pin input data */
        unsigned int ld6_input_data:1;      /* LD6 pin input data */
        unsigned int ld7_input_data:1;      /* LD7 pin input data */
        unsigned int ld8_input_data:1;      /* LD8 pin input data */
        unsigned int ld9_input_data:1;      /* LD9 pin input data */
        unsigned int ld10_input_data:1;     /* LD10 pin input data */
        unsigned int ld11_input_data:1;     /* LD11 pin input data */
        unsigned int ld12_input_data:1;     /* LD12 pin input data */
        unsigned int ld13_input_data:1;     /* LD13 pin input data */
        unsigned int ld14_input_data:1;     /* LD14 pin input data */
        unsigned int ld15_input_data:1;     /* LD15 pin input data */
        unsigned int ld16_input_data:1;     /* LD16 pin input data */
        unsigned int ld17_input_data:1;     /* LD17 pin input data */
        unsigned int undefined_bits_18_31:14;
    };

    uint32_t reg32;
} com_pin_input_data0_t;

#define COM_PIN_INPUT_DATA1_OFFSET 0x313
#define COM_PIN_INPUT_DATA1_RESET  0x00000000
typedef union com_pin_input_data1_u {
    struct {
        unsigned int lpw0_input_data:1;     /* LPW0 pin input data */
        unsigned int lpw1_input_data:1;     /* LPW1 pin input data */
        unsigned int lpw2_input_data:1;     /* LPW2 pin input data */
        unsigned int undefined_bit_3:1;
        unsigned int lsc0_input_data:1;     /* LSC0 pin input data */
        unsigned int lsc1_input_data:1;     /* LSC1 pin input data */
        unsigned int lvs_input_data:1;      /* LVS pin input data */
        unsigned int lhs_input_data:1;      /* LHS pin input data */
        unsigned int lhp0_input_data:1;     /* LHP0 pin input data */
        unsigned int lhp1_input_data:1;     /* LHP1 pin input data */
        unsigned int lhp2_input_data:1;     /* LHP2 pin input data */
        unsigned int undefined_bit_11:1;
        unsigned int lvp0_input_data:1;     /* LVP0 pin input data */
        unsigned int lvp1_input_data:1;     /* LVP1 pin input data */
        unsigned int undefined_bits_14_15:2;
        unsigned int lm0_input_data:1;      /* LM0 pin input data */
        unsigned int lm1_input_data:1;      /* LM1 pin input data */
        unsigned int ldi_input_data:1;      /* LDI pin input data */
        unsigned int lpp_input_data:1;      /* LPP pin input data */
        unsigned int lsck_input_data:1;     /* LSCK pin input data */
        unsigned int lsda_input_data:1;     /* LSDA pin input data */
        unsigned int lcsn_input_data:1;     /* LCSN pin input data */
        unsigned int ldc_input_data:1;      /* LDC pin input data */
        unsigned int lspi_input_data:1;     /* LSPI pin input data */
        unsigned int lsdi_input_data:1;     /* LSDI pin input data */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} com_pin_input_data1_t;

#define COM_PIN_OUTPUT_SELECT0_OFFSET 0x314
#define COM_PIN_OUTPUT_SELECT0_RESET  0x00000000
typedef union com_pin_output_select0_u {
    struct {
        unsigned int ld0_output_select:3;   /* LD0 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int ld1_output_select:3;   /* LD1 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int ld2_output_select:3;   /* LD2 pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int ld3_output_select:3;   /* LD3 pin output select */
        unsigned int undefined_bit_15:1;
        unsigned int ld4_output_select:3;   /* LD4 pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int ld5_output_select:3;   /* LD5 pin output select */
        unsigned int undefined_bit_23:1;
        unsigned int ld6_output_select:3;   /* LD6 pin output select */
        unsigned int undefined_bit_27:1;
        unsigned int ld7_output_select:3;   /* LD7 pin output select */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_select0_t;

#define COM_PIN_OUTPUT_SELECT1_OFFSET 0x315
#define COM_PIN_OUTPUT_SELECT1_RESET  0x00000000
typedef union com_pin_output_select1_u {
    struct {
        unsigned int ld8_output_select:3;   /* LD8 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int ld9_output_select:3;   /* LD9 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int ld10_output_select:3;  /* LD10 pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int ld11_output_select:3;  /* LD11 pin output select */
        unsigned int undefined_bit_15:1;
        unsigned int ld12_output_select:3;  /* LD12 pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int ld13_output_select:3;  /* LD13 pin output select */
        unsigned int undefined_bit_23:1;
        unsigned int ld14_output_select:3;  /* LD14 pin output select */
        unsigned int undefined_bit_27:1;
        unsigned int ld15_output_select:3;  /* LD15 pin output select */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_select1_t;

#define COM_PIN_OUTPUT_SELECT2_OFFSET 0x316
#define COM_PIN_OUTPUT_SELECT2_RESET  0x00000000
typedef union com_pin_output_select2_u {
    struct {
        unsigned int ld16_output_select:3;  /* LD16 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int ld17_output_select:3;  /* LD17 pin output select */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} com_pin_output_select2_t;

#define COM_PIN_OUTPUT_SELECT3_OFFSET 0x317
#define COM_PIN_OUTPUT_SELECT3_RESET  0x00000000
typedef union com_pin_output_select3_u {
    struct {
        unsigned int lpw0_output_select:3;  /* LCD_PWR0 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lpw1_output_select:3;  /* LCD_PWR1 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int lpw2_output_select:3;  /* LCD_PWR2 pin output select */
        unsigned int undefined_bits_11_15:5;
        unsigned int lsc0_output_select:3;  /* LCD_PCLK pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int lsc1_output_select:3;  /* LCD_WR_N pin output select */
        unsigned int undefined_bit_23:1;
        unsigned int lvs_output_select:3;   /* LCD_VSYNC pin output select */
        unsigned int undefined_bit_27:1;
        unsigned int lhs_output_select:3;   /* LCD_HSYNC pin output select */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_select3_t;

#define COM_PIN_OUTPUT_SELECT4_OFFSET 0x318
#define COM_PIN_OUTPUT_SELECT4_RESET  0x00000000
typedef union com_pin_output_select4_u {
    struct {
        unsigned int lhp0_output_select:3;  /* LCD_D21 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lhp1_output_select:3;  /* LCD_D18 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int lhp2_output_select:3;  /* LCD_D19 pin output select */
        unsigned int undefined_bits_11_15:5;
        unsigned int lvp0_output_select:3;  /* LCD_DC1 pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int lvp1_output_select:3;  /* LCD_D20 pin output select */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_output_select4_t;

#define COM_PIN_OUTPUT_SELECT5_OFFSET 0x319
#define COM_PIN_OUTPUT_SELECT5_RESET  0x00000000
typedef union com_pin_output_select5_u {
    struct {
        unsigned int lm0_output_select:3;   /* LCD_CS1_N pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lm1_output_select:3;   /* LCD_M1 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int ldi_output_select:3;   /* LCD_D22 pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int lpp_output_select:3;   /* LCD_D23 pin output select */
        unsigned int undefined_bits_15_31:17;
    };

    uint32_t reg32;
} com_pin_output_select5_t;

#define COM_PIN_OUTPUT_SELECT6_OFFSET 0x31A
#define COM_PIN_OUTPUT_SELECT6_RESET  0x00000000
typedef union com_pin_output_select6_u {
    struct {
        unsigned int lsck_output_select:3;  /* LSCK pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lsda_output_select:3;  /* LSDA pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int lcsn_output_select:3;  /* LCSN pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int ldc_output_select:3;   /* LDC pin output select */
        unsigned int undefined_bit_15:1;
        unsigned int lspi_output_select:3;  /* LSPI pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int lsdi_output_select:3;  /* LSDI pin output select */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_output_select6_t;

#define COM_PIN_MISC_CONTROL_OFFSET 0x31B
#define COM_PIN_MISC_CONTROL_RESET  0x00000000
typedef union com_pin_misc_control_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int disp_clock_output:1;   /* Display Clock (DCLK) Enable 0= disable 1= enable display clock to be output on LCD_DE pin (LCD_DE output select must be appropriately programmed for this to be effective) 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} com_pin_misc_control_t;

#define COM_PM0_CONTROL_OFFSET 0x31C
#define COM_PM0_CONTROL_RESET  0x00000000
typedef union com_pm0_control_u {
    struct {
        unsigned int pm0_clock_select:2;    /* PM0 Clock Select 0= output of shift clock divider 1= pixel clock 2= line clock 3= frame clock Notes: 1) Pixel clock, line clock, and frame clock is running only when PW0 signal is enabled. 2) In non-continuous mode, shift clock and pixel clock run continuously, but line clock and frame clock only run while a frame is being sent */
        unsigned int undefined_bits_2_3:2;
        unsigned int pm0_clock_divider:6;   /* PM0 Clock Divider (1 to 64) */
        unsigned int undefined_bits_10_17:8;
        unsigned int pm0_period:6;          /* PM0 Period (4, 8, ... , 256 clock cycles) */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} com_pm0_control_t;

#define COM_PM0_DUTY_CYCLE_OFFSET 0x31D
#define COM_PM0_DUTY_CYCLE_RESET  0x00000000
typedef union com_pm0_duty_cycle_u {
    struct {
        unsigned int pm0_duty_cycle:9;      /* PM0 Duty Cycle (or D) From 1/P to D/P pulse high time where P is the period. This must not be larger than the period */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} com_pm0_duty_cycle_t;

#define COM_PM1_CONTROL_OFFSET 0x31E
#define COM_PM1_CONTROL_RESET  0x00000000
typedef union com_pm1_control_u {
    struct {
        unsigned int pm1_clock_select:2;    /* PM1 Clock Select 0= output of shift clock divider 1= pixel clock 2= line clock 3= frame clock Notes: 1) Pixel clock, line clock, and frame clock is running only when PW0 signal is enabled. 2) In non-continuous mode, shift clock and pixel clock run continuously, but line clock and frame clock only run while a frame is being sent */
        unsigned int undefined_bits_2_3:2;
        unsigned int pm1_clock_divider:6;   /* PM1 Clock Divider (1 to 64) */
        unsigned int undefined_bits_10_17:8;
        unsigned int pm1_period:6;          /* PM1 Period (4, 8, ... , 256 clock cycles) */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} com_pm1_control_t;

#define COM_PM1_DUTY_CYCLE_OFFSET 0x31F
#define COM_PM1_DUTY_CYCLE_RESET  0x00000000
typedef union com_pm1_duty_cycle_u {
    struct {
        unsigned int pm1_duty_cycle:9;      /* PM1 Duty Cycle from 1/P to P/P pulse high time where P is the period. This must not be larger than the period */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} com_pm1_duty_cycle_t;

#define COM_SPI_CONTROL_OFFSET 0x320
#define COM_SPI_CONTROL_RESET  0x00000000
typedef union com_spi_control_u {
    struct {
        unsigned int spi_serial_clk_control:2;/* SPI Serial Clock Control 0= SCK rising edge is active edge 1-clock chip select and no SCK clock edge to latch chip select 1= SCK rising edge is active edge 2-clock chip select with SCK rising clock edge to latch it 2= SCK falling edge is active edge 1-clock chip select and no SCK clock edge to latch chip select 3= SCK falling edge is active edge 2-clock chip select with SCK falling clock edge to latch it This is valid for Host, IS, and LCD SPI */
        unsigned int undefined_bit_2:1;
        unsigned int spi_data_direction:1;  /* SPI Data Direction. This is valid for Host SPI and for sending initialization sequence (IS SPI) only. Note that data direction does not affect the start byte direction (always msb to lsb) and position (always first 8-bit of serial data) for SPI16SB mode. 0 = MSB2LSB 1 = LSB2MSB */
        unsigned int spi_bits_per_cycle:4;  /* SPI Bits per Cycle This is valid for Host and IS SPI only. This parameter determines the number of bits/cycle when SPI is used for host write or for sending initialization sequence. If SPI is used for sending pixel data to the display then pixel clock divider determines the SPI bits/cycle. SPI8DC is 8-bit SPI plus data/command bit SPI16DC is 16-bit SPI plus data/command bit SPI16SB is 16-bit SPI plus an 8-bit start byte preceding the 16-bit data. 0 = SPI8 1 = SPI8DC 2 = SPI12 3 = SPI16 4 = SPI16DC 5 = SPI16SB 6 = SPI18 7 = SPI24 */
        unsigned int undefined_bits_8_15:8;
        unsigned int spi_clk_divider:5;     /* SPI Clock Divider (1 to 32) This clock divider is used only if SPI is enabled for host writes (Host SPI) or for sending initialization sequence (IS SPI). Programmed value is 1 less than the desired (actual) clock divider value. This parameter is forced to 0 (clock divide by 1) for LCD SPI */
        unsigned int undefined_bits_21_23:3;
        unsigned int spi_status_enable:2;   /* SPI Status Enable 00= SPI status disable 01= SPI status enabled for host SPI only 10= SPI status enabled for IS and LCD SPI only 11= SPI status enabled for all SPI cycles SPI status is reflected in SPI_BUSY bit and can generate interrupt. SPI status indicates when SPI module is busy (SPI write cycles are in progress) so its falling edge should be used to generate interrupt. SPI status can also be output on LCD_DE pin. When Host SPI is triggered, the SPI busy is asserted within three display clock cycles after the end of the host write cycle. SPI status is disabled when SPI_ENABLE bit is disabled */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} com_spi_control_t;

#define COM_SPI_START_BYTE_OFFSET 0x321
#define COM_SPI_START_BYTE_RESET  0x00000000
typedef union com_spi_start_byte_u {
    struct {
        unsigned int spi_data_start_byte:8; /* SPI Data Start Byte This is valid for Host, IS, and LCD SPI */
        unsigned int spi_command_start_byte:8;/* SPI Command Start Byte This is valid for Host, IS, and LCD SPI */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} com_spi_start_byte_t;

#define COM_HSPI_WRITE_DATA_AB_OFFSET 0x322
#define COM_HSPI_WRITE_DATA_AB_RESET  0x00000000
typedef union com_hspi_write_data_ab_u {
    struct {
        unsigned int hspi_write_data_a:16;  /* Host SPI Write Data A bits 15-0 */
        unsigned int hspi_write_data_b:16;  /* Host SPI Write Data B bits 15-0 */
    };

    uint32_t reg32;
} com_hspi_write_data_ab_t;

#define COM_HSPI_WRITE_DATA_CD_OFFSET 0x323
#define COM_HSPI_WRITE_DATA_CD_RESET  0x00000000
typedef union com_hspi_write_data_cd_u {
    struct {
        unsigned int hspi_write_data_c:16;  /* Host SPI Write Data C bits 15-0 */
        unsigned int hspi_write_data_d:16;  /* Host SPI Write Data D bits 15-0 */
    };

    uint32_t reg32;
} com_hspi_write_data_cd_t;

#define COM_HSPI_CS_DC_OFFSET 0x324
#define COM_HSPI_CS_DC_RESET  0x00000000
typedef union com_hspi_cs_dc_u {
    struct {
        unsigned int hspi_raise:1;          /* Host SPI Raise. Raise vector will be returned at the end of the host SPI write cycles 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_1_3:3;
        unsigned int hspi_dc:4;             /* Host SPI Data/Command_ (SDC) 0= Command cycle (SDC=0) 1= Data cycle (SDC=1) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles */
        unsigned int hspi_main_cs:4;        /* Host SPI Main display Chip Select (Main SCS_) 0= Main display not selected (Main SCS_=1) 1= Main display selected (Main SCS_=0) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles */
        unsigned int hspi_sub_cs:4;         /* Host SPI Sub display Chip Select (Sub SCS_) 0= Sub display not selected (Sub SCS_=1) 1= Sub display selected (Sub SCS_=0) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles */
        unsigned int hspi_raise_channel_id:4;/* Win G Channel ID */
        unsigned int undefined_bits_20_23:4;
        unsigned int hspi_raise_vector:5;   /* Host SPI Raise Vector This raise vector is returned after all the triggered host SPI cycles are executed */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} com_hspi_cs_dc_t;

#define COM_SCRATCH_REGISTER_A_OFFSET 0x325
#define COM_SCRATCH_REGISTER_A_RESET  0x00000000
typedef union com_scratch_register_a_u {
    struct {
        unsigned int scratch_register_a:32; /* Scratch Register A */
    };

    uint32_t reg32;
} com_scratch_register_a_t;

#define COM_SCRATCH_REGISTER_B_OFFSET 0x326
#define COM_SCRATCH_REGISTER_B_RESET  0x00000000
typedef union com_scratch_register_b_u {
    struct {
        unsigned int scratch_register_b:32; /* Scratch Register B */
    };

    uint32_t reg32;
} com_scratch_register_b_t;

#define COM_GPIO_CTRL_OFFSET 0x327
#define COM_GPIO_CTRL_RESET  0x00000000
typedef union com_gpio_ctrl_u {
    struct {
        unsigned int gpio_0_debounce_enable:1;/* maps to display pin LCD_PWR0  0 = DISABLE 1 = ENABLE */
        unsigned int gpio_1_debounce_enable:1;/* maps to display pin LCD_PWR1  0 = DISABLE 1 = ENABLE */
        unsigned int gpio_2_debounce_enable:1;/* maps to display pin LCD_PWR2  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} com_gpio_ctrl_t;

#define COM_GPIO_DEBOUNCE_COUNTER_OFFSET 0x328
#define COM_GPIO_DEBOUNCE_COUNTER_RESET  0x00000400
typedef union com_gpio_debounce_counter_u {
    struct {
        unsigned int debounce_counter:32;
    };

    uint32_t reg32;
} com_gpio_debounce_counter_t;

#define COM_CRC_CHECKSUM_LATCHED_OFFSET 0x329
#define COM_CRC_CHECKSUM_LATCHED_RESET  0x00000000
typedef union com_crc_checksum_latched_u {
    struct {
        unsigned int crc_checksum_latched:32;/* CRC Checksum latched */
    };

    uint32_t reg32;
} com_crc_checksum_latched_t;

#define DISP_DISP_SIGNAL_OPTIONS0_OFFSET 0x400
#define DISP_DISP_SIGNAL_OPTIONS0_RESET  0x00000000
typedef union disp_disp_signal_options0_u {
    struct {
        unsigned int undefined_bits_0_7:8;
        unsigned int h_pulse0_enable:1;     /* H Pulse 0 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int h_pulse1_enable:1;     /* H Pulse 1 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int h_pulse2_enable:1;     /* H Pulse 2 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_enable:1;     /* V Pulse 0 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int v_pulse1_enable:1;     /* V Pulse 1 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int v_pulse2_enable:1;     /* V Pulse 2 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int v_pulse3_enable:1;     /* V Pulse 3 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_23:3;
        unsigned int m0_enable:1;           /* M0 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_25:1;
        unsigned int m1_enable:1;           /* M1 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_27_31:5;
    };

    uint32_t reg32;
} disp_disp_signal_options0_t;

#define DISP_DISP_SIGNAL_OPTIONS1_OFFSET 0x401
#define DISP_DISP_SIGNAL_OPTIONS1_RESET  0x00000000
typedef union disp_disp_signal_options1_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int di_enable:1;           /* DI Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int pp_enable:1;           /* PP Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} disp_disp_signal_options1_t;

#define DISP_DISP_WIN_OPTIONS_OFFSET 0x402
#define DISP_DISP_WIN_OPTIONS_RESET  0x00000000
typedef union disp_disp_win_options_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int cursor_enable:1;       /* Cursor Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_17_27:11;
        unsigned int tvo_enable:1;          /* TVO Enable. Steps to start displaying on TV (The order of the first 3 steps can freely change): -- Program and enable TVO module -- Program DISPLAY_CTRL_MODE to NC_DISPLAY -- Program the ASSEMBLY shadow copy of this register field with ENABLE -- Program GENERAL_ACT_REQ to activate the shadow 0 = DISABLE 1 = ENABLE */
        unsigned int dsi_enable:1;          /* MIPI Display Serial Interface Enable. The DSI unit must also be separately enabled in its own register space in order to use DSI functionality. 0 = DISABLE 1 = ENABLE */
        unsigned int hdmi_enable:1;         /* HDMI interface. The HDMI unit must also be separately enabled in its own register space in order to use HDMI functionality. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} disp_disp_win_options_t;

#define DISP_MEM_HIGH_PRIORITY_OFFSET 0x403
#define DISP_MEM_HIGH_PRIORITY_RESET  0x00000000
typedef union disp_mem_high_priority_u {
    struct {
        unsigned int cbr_display0a2mc_hpth:8;/* Window A Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request */
        unsigned int cbr_displayb2mc_hpth:7;/* Window B Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request. This register is used for both window B0 and B1 */
        unsigned int undefined_bit_15:1;
        unsigned int cbr_display0c2mc_hpth:7;/* Window C Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request */
        unsigned int undefined_bit_23:1;
        unsigned int csr_displayhc2mc_hpth:3;/* Cursor Memory High Priority enable 0= memory access for cursor is normal priority 1= memory access for cursor is high priority */
        unsigned int undefined_bits_27_31:5;
    };

    uint32_t reg32;
} disp_mem_high_priority_t;

#define DISP_MEM_HIGH_PRIORITY_TIMER_OFFSET 0x404
#define DISP_MEM_HIGH_PRIORITY_TIMER_RESET  0x00000000
typedef union disp_mem_high_priority_timer_u {
    struct {
        unsigned int cbr_display0a2mc_hptm:6;/* Window A Memory High Priority timer */
        unsigned int undefined_bits_6_7:2;
        unsigned int cbr_displayb2mc_hptm:6;/* Window B Memory High Priority timer This register is used for both window B0 and B1 */
        unsigned int undefined_bits_14_15:2;
        unsigned int cbr_display0c2mc_hptm:6;/* Window C Memory High Priority timer */
        unsigned int undefined_bits_22_23:2;
        unsigned int csr_displayhc2mc_hptm:6;/* Cursor Memory High Priority timer */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_mem_high_priority_timer_t;

#define DISP_DISP_TIMING_OPTIONS_OFFSET 0x405
#define DISP_DISP_TIMING_OPTIONS_RESET  0x00000000
typedef union disp_disp_timing_options_u {
    struct {
        unsigned int vsync_h_position:13;   /* VSYNC Horizontal Position This parameter specifies the position where VSYNC can toggle with respect to H reference point */
        unsigned int undefined_bits_13_31:19;
    };

    uint32_t reg32;
} disp_disp_timing_options_t;

#define DISP_REF_TO_SYNC_OFFSET 0x406
#define DISP_REF_TO_SYNC_RESET  0x00000000
typedef union disp_ref_to_sync_u {
    struct {
        unsigned int h_ref_to_sync:13;      /* H reference to HSYNC (minimum 0 pixel clock) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_ref_to_sync:13;      /* V reference to VSYNC (minimum 1 line clock) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_ref_to_sync_t;

#define DISP_SYNC_WIDTH_OFFSET 0x407
#define DISP_SYNC_WIDTH_RESET  0x00000000
typedef union disp_sync_width_u {
    struct {
        unsigned int h_sync_width:13;       /* HSYNC pulse width (minimum 1 pixel clock) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_sync_width:13;       /* VSYNC pulse width (minimum 1 line clock) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_sync_width_t;

#define DISP_BACK_PORCH_OFFSET 0x408
#define DISP_BACK_PORCH_RESET  0x00000000
typedef union disp_back_porch_u {
    struct {
        unsigned int h_back_porch:13;       /* H back porch */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_back_porch:13;       /* V back porch */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_back_porch_t;

#define DISP_DISP_ACTIVE_OFFSET 0x409
#define DISP_DISP_ACTIVE_RESET  0x00000000
typedef union disp_disp_active_u {
    struct {
        unsigned int h_disp_active:13;      /* H display active width (minimum 16 pixels) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_disp_active:13;      /* V display active width (minimum 16 lines) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_disp_active_t;

#define DISP_FRONT_PORCH_OFFSET 0x40A
#define DISP_FRONT_PORCH_RESET  0x00000000
typedef union disp_front_porch_u {
    struct {
        unsigned int h_front_porch:13;      /* HSYNC front porch (minimum -=PS_=-H_REF_TO_SYNC + 1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_front_porch:13;      /* VSYNC front porch (minimum -=PS_=-V_REF_TO_SYNC + 1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_front_porch_t;

#define DISP_H_PULSE0_CONTROL_OFFSET 0x40B
#define DISP_H_PULSE0_CONTROL_RESET  0x00000000
typedef union disp_h_pulse0_control_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int h_pulse0_mode:1;       /* H Pulse 0 Mode 0= Normal mode 1= Single-clock mode 0 = NORMAL 1 = ONE_CLOCK */
        unsigned int h_pulse0_polarity:1;   /* H Pulse 0 Polarity. Polarity adjustment is done before the vertical qualifier is applied. 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int h_pulse0_v_qual:2;     /* H Pulse 0 Vertical Qualifier 0= always running 2= run during vertical active area 3= run during vertical active plus 1 line 0 = ALWAYS 2 = VACTIVE 3 = VACTIVE1 */
        unsigned int h_pulse0_last:4;       /* H Pulse 0 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position 6= end on Start D position 7= end on End D position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C 6 = START_D 7 = END_D */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_h_pulse0_control_t;

#define DISP_H_PULSE0_POSITION_A_OFFSET 0x40C
#define DISP_H_PULSE0_POSITION_A_RESET  0x00000000
typedef union disp_h_pulse0_position_a_u {
    struct {
        unsigned int h_pulse0_start_a:13;   /* H Pulse 0 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_a:13;     /* H Pulse 0 End A (minimum -=PS_=-H_PULSE0_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse0_position_a_t;

#define DISP_H_PULSE0_POSITION_B_OFFSET 0x40D
#define DISP_H_PULSE0_POSITION_B_RESET  0x00000000
typedef union disp_h_pulse0_position_b_u {
    struct {
        unsigned int h_pulse0_start_b:13;   /* H Pulse 0 Start B (minimum -=PS_=-H_PULSE0_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_b:13;     /* H Pulse 0 End B (minimum -=PS_=-H_PULSE0_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse0_position_b_t;

#define DISP_H_PULSE0_POSITION_C_OFFSET 0x40E
#define DISP_H_PULSE0_POSITION_C_RESET  0x00000000
typedef union disp_h_pulse0_position_c_u {
    struct {
        unsigned int h_pulse0_start_c:13;   /* H Pulse 0 Start C (minimum -=PS_=-H_PULSE0_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_c:13;     /* H Pulse 0 End C (minimum -=PS_=-H_PULSE0_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse0_position_c_t;

#define DISP_H_PULSE0_POSITION_D_OFFSET 0x40F
#define DISP_H_PULSE0_POSITION_D_RESET  0x00000000
typedef union disp_h_pulse0_position_d_u {
    struct {
        unsigned int h_pulse0_start_d:13;   /* H Pulse 0 Start D (minimum -=PS_=-H_PULSE0_END_C+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_d:13;     /* H Pulse 0 End D (minimum -=PS_=-H_PULSE0_START_D+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse0_position_d_t;

#define DISP_H_PULSE1_CONTROL_OFFSET 0x410
#define DISP_H_PULSE1_CONTROL_RESET  0x00000000
typedef union disp_h_pulse1_control_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int h_pulse1_mode:1;       /* H Pulse 1 Mode 0= Normal mode 1= Single-clock mode 0 = NORMAL 1 = ONE_CLOCK */
        unsigned int h_pulse1_polarity:1;   /* H Pulse 1 Polarity. Polarity adjustment is done before the vertical qualifier is applied 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int h_pulse1_v_qual:2;     /* H Pulse 1 Vertical Qualifier 0= always running 2= run during vertical active area 3= run during vertical active plus 1 line 0 = ALWAYS 2 = VACTIVE 3 = VACTIVE1 */
        unsigned int h_pulse1_last:4;       /* H Pulse 1 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position 6= end on Start D position 7= end on End D position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C 6 = START_D 7 = END_D */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_h_pulse1_control_t;

#define DISP_H_PULSE1_POSITION_A_OFFSET 0x411
#define DISP_H_PULSE1_POSITION_A_RESET  0x00000000
typedef union disp_h_pulse1_position_a_u {
    struct {
        unsigned int h_pulse1_start_a:13;   /* H Pulse 1 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_a:13;     /* H Pulse 1 End A (minimum -=PS_=-H_PULSE1_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse1_position_a_t;

#define DISP_H_PULSE1_POSITION_B_OFFSET 0x412
#define DISP_H_PULSE1_POSITION_B_RESET  0x00000000
typedef union disp_h_pulse1_position_b_u {
    struct {
        unsigned int h_pulse1_start_b:13;   /* H Pulse 1 Start B (minimum -=PS_=-H_PULSE1_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_b:13;     /* H Pulse 1 End B (minimum -=PS_=-H_PULSE1_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse1_position_b_t;

#define DISP_H_PULSE1_POSITION_C_OFFSET 0x413
#define DISP_H_PULSE1_POSITION_C_RESET  0x00000000
typedef union disp_h_pulse1_position_c_u {
    struct {
        unsigned int h_pulse1_start_c:13;   /* H Pulse 1 Start C (minimum -=PS_=-H_PULSE1_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_c:13;     /* H Pulse 1 End C (minimum -=PS_=-H_PULSE1_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse1_position_c_t;

#define DISP_H_PULSE1_POSITION_D_OFFSET 0x414
#define DISP_H_PULSE1_POSITION_D_RESET  0x00000000
typedef union disp_h_pulse1_position_d_u {
    struct {
        unsigned int h_pulse1_start_d:13;   /* H Pulse 1 Start D (minimum -=PS_=-H_PULSE1_END_C+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_d:13;     /* H Pulse 1 End D (minimum -=PS_=-H_PULSE1_START_D+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse1_position_d_t;

#define DISP_H_PULSE2_CONTROL_OFFSET 0x415
#define DISP_H_PULSE2_CONTROL_RESET  0x00000000
typedef union disp_h_pulse2_control_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int h_pulse2_mode:1;       /* H Pulse 2 Mode 0= Normal mode 1= Single-clock mode 0 = NORMAL 1 = ONE_CLOCK */
        unsigned int h_pulse2_polarity:1;   /* H Pulse 2 Polarity. Polarity adjustment is done before the vertical qualifier is applied 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int h_pulse2_v_qual:2;     /* H Pulse 2 Vertical Qualifier 0= always running 2= run during vertical active area 3= run during vertical active plus 1 line 0 = ALWAYS 2 = VACTIVE 3 = VACTIVE1 */
        unsigned int h_pulse2_last:4;       /* H Pulse 2 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position 6= end on Start D position 7= end on End D position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C 6 = START_D 7 = END_D */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_h_pulse2_control_t;

#define DISP_H_PULSE2_POSITION_A_OFFSET 0x416
#define DISP_H_PULSE2_POSITION_A_RESET  0x00000000
typedef union disp_h_pulse2_position_a_u {
    struct {
        unsigned int h_pulse2_start_a:13;   /* H Pulse 2 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_a:13;     /* H Pulse 2 End A (minimum -=PS_=-H_PULSE2_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse2_position_a_t;

#define DISP_H_PULSE2_POSITION_B_OFFSET 0x417
#define DISP_H_PULSE2_POSITION_B_RESET  0x00000000
typedef union disp_h_pulse2_position_b_u {
    struct {
        unsigned int h_pulse2_start_b:13;   /* H Pulse 2 Start B (minimum -=PS_=-H_PULSE2_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_b:13;     /* H Pulse 2 End B (minimum -=PS_=-H_PULSE2_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse2_position_b_t;

#define DISP_H_PULSE2_POSITION_C_OFFSET 0x418
#define DISP_H_PULSE2_POSITION_C_RESET  0x00000000
typedef union disp_h_pulse2_position_c_u {
    struct {
        unsigned int h_pulse2_start_c:13;   /* H Pulse 2 Start C (minimum -=PS_=-H_PULSE2_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_c:13;     /* H Pulse 2 End C (minimum -=PS_=-H_PULSE2_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse2_position_c_t;

#define DISP_H_PULSE2_POSITION_D_OFFSET 0x419
#define DISP_H_PULSE2_POSITION_D_RESET  0x00000000
typedef union disp_h_pulse2_position_d_u {
    struct {
        unsigned int h_pulse2_start_d:13;   /* H Pulse 2 Start D (minimum -=PS_=-H_PULSE2_END_C+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_d:13;     /* H Pulse 2 End D (minimum -=PS_=-H_PULSE2_START_D+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse2_position_d_t;

#define DISP_V_PULSE0_CONTROL_OFFSET 0x41A
#define DISP_V_PULSE0_CONTROL_RESET  0x00000000
typedef union disp_v_pulse0_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse0_polarity:1;   /* V Pulse 0 Polarity 0= High 1= Low 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int v_pulse0_delay:2;      /* V Pulse 0 Delay 0= no delay 1= 1-line delay 2= 2-line delay 3= reserved 0 = NODELAY 1 = DELAY1 2 = DELAY2 */
        unsigned int v_pulse0_last:4;       /* V Pulse 0 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C */
        unsigned int undefined_bits_12_15:4;
        unsigned int v_pulse0_h_position:13;/* V Pulse 0 Horizontal Position This parameter specifies the position where V Pulse 0 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse0_control_t;

#define DISP_V_PULSE0_POSITION_A_OFFSET 0x41B
#define DISP_V_PULSE0_POSITION_A_RESET  0x00000000
typedef union disp_v_pulse0_position_a_u {
    struct {
        unsigned int v_pulse0_start_a:13;   /* V Pulse 0 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_end_a:13;     /* V Pulse 0 End A (minimum -=PS_=-V_PULSE0_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse0_position_a_t;

#define DISP_V_PULSE0_POSITION_B_OFFSET 0x41C
#define DISP_V_PULSE0_POSITION_B_RESET  0x00000000
typedef union disp_v_pulse0_position_b_u {
    struct {
        unsigned int v_pulse0_start_b:13;   /* V Pulse 0 Start B (minimum -=PS_=-V_PULSE0_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_end_b:13;     /* V Pulse 0 End B (minimum -=PS_=-V_PULSE0_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse0_position_b_t;

#define DISP_V_PULSE0_POSITION_C_OFFSET 0x41D
#define DISP_V_PULSE0_POSITION_C_RESET  0x00000000
typedef union disp_v_pulse0_position_c_u {
    struct {
        unsigned int v_pulse0_start_c:13;   /* V Pulse 0 Start C (minimum -=PS_=-V_PULSE0_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_end_c:13;     /* V Pulse 0 End C (minimum -=PS_=-V_PULSE0_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse0_position_c_t;

#define DISP_V_PULSE1_CONTROL_OFFSET 0x41E
#define DISP_V_PULSE1_CONTROL_RESET  0x00000000
typedef union disp_v_pulse1_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse1_polarity:1;   /* V pulse 1 Polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int v_pulse1_delay:2;      /* V pulse 1 Delay 0= no delay 1= 1-line delay 2= 2-line delay 3= reserved 0 = NODELAY 1 = DELAY1 2 = DELAY2 */
        unsigned int v_pulse1_last:4;       /* V pulse 1 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C */
        unsigned int undefined_bits_12_15:4;
        unsigned int v_pulse1_h_position:13;/* V Pulse 1 Horizontal Position This parameter specifies the position where V Pulse 1 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse1_control_t;

#define DISP_V_PULSE1_POSITION_A_OFFSET 0x41F
#define DISP_V_PULSE1_POSITION_A_RESET  0x00000000
typedef union disp_v_pulse1_position_a_u {
    struct {
        unsigned int v_pulse1_start_a:13;   /* V Pulse 1 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse1_end_a:13;     /* V Pulse 1 End A (minimum -=PS_=-V_PULSE1_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse1_position_a_t;

#define DISP_V_PULSE1_POSITION_B_OFFSET 0x420
#define DISP_V_PULSE1_POSITION_B_RESET  0x00000000
typedef union disp_v_pulse1_position_b_u {
    struct {
        unsigned int v_pulse1_start_b:13;   /* V Pulse 1 Start B (minimum -=PS_=-V_PULSE1_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse1_end_b:13;     /* V Pulse 1 End B (minimum -=PS_=-V_PULSE1_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse1_position_b_t;

#define DISP_V_PULSE1_POSITION_C_OFFSET 0x421
#define DISP_V_PULSE1_POSITION_C_RESET  0x00000000
typedef union disp_v_pulse1_position_c_u {
    struct {
        unsigned int v_pulse1_start_c:13;   /* V Pulse 1 Start C (minimum -=PS_=-V_PULSE1_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse1_end_c:13;     /* V Pulse 1 End C (minimum -=PS_=-V_PULSE1_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse1_position_c_t;

#define DISP_V_PULSE2_CONTROL_OFFSET 0x422
#define DISP_V_PULSE2_CONTROL_RESET  0x00000000
typedef union disp_v_pulse2_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse2_polarity:1;   /* V pulse 2 Polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_5_7:3;
        unsigned int v_pulse2_last:1;       /* V pulse 2 Last point 0= end on Start A position 1= end on End A position others= reserved 0 = START_A 1 = END_A */
        unsigned int undefined_bits_9_15:7;
        unsigned int v_pulse2_h_position:13;/* V Pulse 2 Horizontal Position This parameter specifies the position where V Pulse 2 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse2_control_t;

#define DISP_V_PULSE2_POSITION_A_OFFSET 0x423
#define DISP_V_PULSE2_POSITION_A_RESET  0x00000000
typedef union disp_v_pulse2_position_a_u {
    struct {
        unsigned int v_pulse2_start_a:13;   /* V Pulse 2 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse2_end_a:13;     /* V Pulse 2 End A (minimum -=PS_=-V_PULSE2_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse2_position_a_t;

#define DISP_V_PULSE3_CONTROL_OFFSET 0x424
#define DISP_V_PULSE3_CONTROL_RESET  0x00000000
typedef union disp_v_pulse3_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse3_polarity:1;   /* V pulse 3 Polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_5_7:3;
        unsigned int v_pulse3_last:1;       /* V pulse 3 Last point 0= end on Start A position 1= end on End A position others= reserved 0 = START_A 1 = END_A */
        unsigned int undefined_bits_9_15:7;
        unsigned int v_pulse3_h_position:13;/* V Pulse 3 Horizontal Position This parameter specifies the position where V Pulse 3 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse3_control_t;

#define DISP_V_PULSE3_POSITION_A_OFFSET 0x425
#define DISP_V_PULSE3_POSITION_A_RESET  0x00000000
typedef union disp_v_pulse3_position_a_u {
    struct {
        unsigned int v_pulse3_start_a:13;   /* V Pulse 3 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse3_end_a:13;     /* V Pulse 3 End A (minimum -=PS_=-V_PULSE3_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse3_position_a_t;

#define DISP_M0_CONTROL_OFFSET 0x426
#define DISP_M0_CONTROL_RESET  0x00000000
typedef union disp_m0_control_u {
    struct {
        unsigned int m0_clock_select:2;     /* M0 Clock Select 00= pixel clock (for diagnostic) 01= reserved 10= line clock 11= frame clock 0 = PCLK 2 = LCLK 3 = FCLK */
        unsigned int undefined_bits_2_3:2;
        unsigned int m0_phase_control:2;    /* M0 Phase Control 00= free-running 01= reserved 10= reset at beginning of vertical active display 11= invert at beginning of frame This should be set to free-running if frame clock is used. 0 = FREE_RUN 2 = VACTIVE_RESTART 3 = FRAME_INVERT */
        unsigned int m0_phase_reset:1;      /* M0 Phase Reset This bit is effective only when M0 is not free running. 0= frequency (phase) counter is not reset 1= frequency (phase) counter is reset at beginning of vertical active display if phase control is set to VACTIVE_RESTART or at beginning of frame if phase control is set to FRAME_INVERT 0 = DISABLE 1 = ENABLE */
        unsigned int m0_polarity:1;         /* M0 Polarity. Polarity adjustment is applied last after phase control is applied. 0 = HIGH 1 = LOW */
        unsigned int m0_period:5;           /* M0 Period This should be program to the half of the desired M0 period (in lines) minus 1 */
        unsigned int undefined_bits_13_15:3;
        unsigned int m0_h_position:13;      /* M0 Horizontal Position This parameter specifies the position where M0 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_m0_control_t;

#define DISP_M1_CONTROL_OFFSET 0x427
#define DISP_M1_CONTROL_RESET  0x00000000
typedef union disp_m1_control_u {
    struct {
        unsigned int m1_clock_select:2;     /* M1 Clock Select 00= pixel clock (for diagnostic) 01= synchronous to M0 provided that M0 is generated using line clock. This will not work if M0 is not generated using line clock. In this case, M1 is controlled by -=PS_=-M0_PHASE_RESET and -=PS_=-M0_PERIOD, -=PS_=-M1_PHASE_CONTROL and -=PS_=-M1_POLARITY. 10= line clock 11= frame clock 0 = PCLK 1 = M0SYNC 2 = LCLK 3 = FCLK */
        unsigned int undefined_bits_2_3:2;
        unsigned int m1_phase_control:2;    /* M1 Phase Control 00= free-running 01= reserved 10= reset at beginning of vertical active display 11= invert at beginning of frame This should be set to free-running if frame clock is used. 0 = FREE_RUN 2 = VACTIVE_RESTART 3 = FRAME_INVERT */
        unsigned int m1_phase_reset:1;      /* M1 Phase Reset This bit is effective only when M1 is not free running. 0= frequency (phase) counter is not reset 1= frequency (phase) counter is reset at beginning of vertical active display if phase control is set to VACTIVE_RESTART or at beginning of frame if phase control is set to FRAME_INVERT 0 = DISABLE 1 = ENABLE */
        unsigned int m1_polarity:1;         /* M1 Polarity. Polarity adjustment is applied last after phase control is applied. 0 = HIGH 1 = LOW */
        unsigned int m1_period:5;           /* M1 Period This should be program to the half of the desired M1 period (in lines) minus 1 */
        unsigned int undefined_bits_13_15:3;
        unsigned int m1_h_position:13;      /* M1 Horizontal Position This parameter specifies the position where M0 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_m1_control_t;

#define DISP_DI_CONTROL_OFFSET 0x428
#define DISP_DI_CONTROL_RESET  0x00000000
typedef union disp_di_control_u {
    struct {
        unsigned int di_mode:2;             /* DI signal Mode 00= DI is always low 01= DI is always high 10= DI is forced high every time M0 (before polarity adjustment) toggles from low to high; otherwise then DI toggles every line 11= DI has same frequency (phase) as M0 (before M0 polarity adjustment) */
        unsigned int undefined_bits_2_3:2;
        unsigned int pixdata_inv_select:1;  /* Pixel Data Inversion Select 0= DI signal controls pixel data inversion 1= (DI xor M0) controls pixel data inversion. 0 = DI 1 = DIXORM0 */
        unsigned int undefined_bit_5:1;
        unsigned int pixdata_inv_control:2; /* Pixel Data Inversion Control The control signal for pixel data inversion is defined by -=PS_=-PIXDATA_INV_SELECT 00= no pixel data inversion regardless of control signal state. 01= Pixels 0, 2, 4 ... are inverted if control signal is high. Pixels 1, 3, 5 ... are inverted if control signal is low. 10= Pixels 1, 3, 5 ... are inverted if control signal is high. Pixels 0, 2, 4 ... are inverted if control signal is low. 11= all pixel data is inverted if control signal is high. NOTE: Pixel data inversion is NOT supported for 2-pixel/3-clock 12-bit parallel display data format!!! 0 = NOINV 1 = EVENINV 2 = ODDINV 3 = ALLINV */
        unsigned int undefined_bits_8_15:8;
        unsigned int di_h_position:13;      /* DI signal Horizontal Position This parameter specifies the position where DI signal can toggle with respect to H reference point. It should not be programmed larger than -=PS_=-PP_H_POSITION if DI is used to control PP signal generation */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_di_control_t;

#define DISP_PP_CONTROL_OFFSET 0x429
#define DISP_PP_CONTROL_RESET  0x00000000
typedef union disp_pp_control_u {
    struct {
        unsigned int pp_direction:2;        /* PP Direction (incrementing or decrementing) 0= always from pulse 0 to 127 (regardless of DI signal) 1= 0 to 127 if DI=0 and 127 to 0 if DI=1 2= 127 to 0 if DI=0 and 0 to 127 if DI=1 3= always 127 to 0 regardless of DI 0 = ALWAYS_INC 1 = INC_IF_DI0 2 = DEC_IF_DI0 3 = ALWAYS_DEC */
        unsigned int pp_v_qualifier:2;      /* PP Vertical Qualifier 0= free running (not qualified) 1= V Pulse 1 qualified 2= V Pulse 2 qualified 3= V Pulse 3 qualified 0 = FREE_RUN 1 = VPULSE1 2 = VPULSE2 3 = VPULSE3 */
        unsigned int pp_h_delay:4;          /* PP signal Horizontal Delay (0 to 15) This parameter specifies the position where PP signal generation starts with respect to H reference point. If DI is used to generate PP signal then this parameter should not be smaller than -=PS_=-DI_H_POSITION */
        unsigned int pp_high_pulse:4;       /* PP High Pulse width (1 to 16) */
        unsigned int pp_low_pulse:4;        /* PP Low Pulse width (1 to 16) */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} disp_pp_control_t;

#define DISP_PP_SELECT_A_OFFSET 0x42A
#define DISP_PP_SELECT_A_RESET  0x00000000
typedef union disp_pp_select_a_u {
    struct {
        unsigned int pp_select_a:32;        /* PP Select bits 31 to 0 */
    };

    uint32_t reg32;
} disp_pp_select_a_t;

#define DISP_PP_SELECT_B_OFFSET 0x42B
#define DISP_PP_SELECT_B_RESET  0x00000000
typedef union disp_pp_select_b_u {
    struct {
        unsigned int pp_select_b:32;        /* PP Select bits 63 to 32 */
    };

    uint32_t reg32;
} disp_pp_select_b_t;

#define DISP_PP_SELECT_C_OFFSET 0x42C
#define DISP_PP_SELECT_C_RESET  0x00000000
typedef union disp_pp_select_c_u {
    struct {
        unsigned int pp_select_c:32;        /* PP Select bits 95 to 64 */
    };

    uint32_t reg32;
} disp_pp_select_c_t;

#define DISP_PP_SELECT_D_OFFSET 0x42D
#define DISP_PP_SELECT_D_RESET  0x00000000
typedef union disp_pp_select_d_u {
    struct {
        unsigned int pp_select_d:32;        /* PP Select bits 127 to 96 */
    };

    uint32_t reg32;
} disp_pp_select_d_t;

#define DISP_DISP_CLOCK_CONTROL_OFFSET 0x42E
#define DISP_DISP_CLOCK_CONTROL_RESET  0x00000006
typedef union disp_disp_clock_control_u {
    struct {
        unsigned int shift_clk_divider:8;   /* Shift Clock Divider 0 = divide by 1 1 = divide by 1.5 2 = divide by 2 3 = divide by 2.5 4 = divide by 3 : : : : 254 = divide by 128 255 = divide by 128.5 Pixel clock divider is used to divide output of internal shift clock divider to generate internal pixel clock which is used to clock the internal horizontal and vertical counters. This divider also determines the output format for parallel interface, serial interface, and LCD SPI interface in conjunction with Display Data Format parameter. For 1-pixel/1-clock parallel display interface, valid settings are PCD1, PCD2, and PCD4.  Note that the main reason to use PCD2 and PCD4 is to get higher frequency PP clock because the PP clock is always generated from the output of shift clock divider. For non 1-pixel/1-clock parallel display interface, valid settings are, PCD1H (2-pixel/3-clock), PCD2 (1-pixel/2-clock), and PCD3 (1-pixel/3-clock).  For 1-channel serial display interface, valid settings are PCD3 (3-bpp 1-ch),
 PCD4 (3-bpp 1-ch), PCD6 (6-bpp 1-ch), PCD9 (9-bpp 1-ch), PCD12 (12-bpp 1-ch), PCD16 (16-bpp 1-ch), PCD18 (18-bpp 1-ch).  For 2-channel serial display interface, valid settings are PCD2 (3-bpp 2-ch), PCD3 (6-bpp 2-ch), PCD6 (12-bpp 2-ch), PCD8 (16-bpp 2-ch), PCD9 (18-bpp 2-ch).  For 3-channel serial display interface, valid settings are PCD1 (3-bpp 3-ch), PCD2 (6-bpp 3-ch), PCD3 (9-bpp 3-ch), PCD4 (12-bpp 3-ch), PCD6 (18-bpp 3-ch).  For LCD SPI interface, valid settings are PCD12 (B4G4R4), PCD16 (B5G6R5), PCD18 (B6G6R6), PCD24 (B8G8R8), PCD8 (B5G6R5 with data/command bit), PCD6 (B5G6R5 with data/command start byte - depending on data/command bit), PCD4 (P8 for spi8), PCD9 (B5G6R5 with chip select deassertion at 8-bit boundary, spi16x2), PCD3 (P8 for spidc), PCD2 (B5G6R5 with data/command bit and chip select deassertion at 9-bit boundary, spi16x2dc), and PCD13 (spi12p2, no chip select deassertion between pairs of pixels) */
        unsigned int pixel_clk_divider:4;   /* Pixel Clock Divider 0000= divide by 1 0001= divide by 1.5 0010= divide by 2 0011= divide by 3 0100= divide by 4 0101= divide by 6 0110= divide by 8 0111= divide by 9 1000= divide by 12 1001= divide by 16 1010= divide by 18 1011= divide by 24 1100= divide by 13 other= reserved 0 = PCD1 1 = PCD1H 2 = PCD2 3 = PCD3 4 = PCD4 5 = PCD6 6 = PCD8 7 = PCD9 8 = PCD12 9 = PCD16 10 = PCD18 11 = PCD24 12 = PCD13 */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_disp_clock_control_t;

#define DISP_DISP_INTERFACE_CONTROL_OFFSET 0x42F
#define DISP_DISP_INTERFACE_CONTROL_RESET  0x00000000
typedef union disp_disp_interface_control_u {
    struct {
        unsigned int disp_data_format:4;    /* Display Data Format Pixel Clock Divider is used together with this parameter to determine the exact display data format. 0 = DF1P1C : 0= 1-pixel/1-clock up to 24-bit parallel  1 = DF1P2C24B : 1= 1-pixel/2-clock 24-bit parallel  2 = DF1P2C18B : 2= 1-pixel/2-clock 18-bit parallel or 2-pixel/3-clock 12-bit parallel or 1-pixel/3-clock 18-bit parallel NOTE: for 2-pixel/3-clock 12-bit parallel, the horizontal display active time must be even number of pixels.  3 = DF1P2C16B : 3= 1-pixel/2-clock 16-bit parallel  4 = DF1S : 4= 1-channel serial NOTE: 1-/2-/3-channel serial display interface supported is a low-voltage differential serial interface.  5 = DF2S : 5= 2-channel serial  6 = DF3S : 6= 3-channel serial  7 = DFSPI : 7= SPI serial  8 = DF1P3C24B : 8= 1-pixel/3-clock 24-bit parallel  9 = DF2P1C18B : 9= 2-pixel/1-clock 18-bit parallel */
        unsigned int undefined_bits_4_7:4;
        unsigned int disp_data_alignment:1; /* Display Data Alignment This is effective for parallel display data format and the associated Initialization Sequence (IS). 0= Output data is MSB-aligned For 1-pixel/1-clock parallel display the output data ordering is the same regardless of display Base Color Size.  For 1-pixel/1-clock parallel display data alignment is optimized for 18-bpp so the 24-bit data ordering is: LD[5:0] is blue data bits 7-2 LD[11:6] is green data bits 7-2 LD[17:12] is red data bits 7-2 LD[19:18] is blue data bits 1-0 LD[21:20] is green data bits 1-0 LD[23:22] is red data bits 1-0 Note that LD18 to LD23 signals are multiplexed with control pins (see Pin Output Select definition) 1= Output data is LSB-aligned.  For 1-pixel/1-clock parallel display the output data ordering is determined by display Base Color Size. For 1-pixel/1-clock parallel display data alignment is optimized for 24-bpp as follows: LD[7:0] is blue data bits 7-0 LD[15:8] is green data bits 7-0 LD[23:16] is red data bits 
7-0 Note that LD18 to LD23 signals are multiplexed with control pins (see Pin Output Select definition) 0 = MSB 1 = LSB */
        unsigned int disp_data_order:1;     /* Display Data Order This is effective only for 1-pixel/2-clock 16-/18-/24- bit parallel interface 0= Red pixel is output in the first clock and blue pixel is output in the second cycle 1= Blue pixel is output in the first clock cycle and red pixel is output in the second clock cycle 0 = RED_BLUE 1 = BLUE_RED */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} disp_disp_interface_control_t;

#define DISP_DISP_COLOR_CONTROL_OFFSET 0x430
#define DISP_DISP_COLOR_CONTROL_RESET  0x00000000
typedef union disp_disp_color_control_u {
    struct {
        unsigned int base_color_size:4;     /* Display Base Color Size This parameter determines the number of bits per color after dither. 0= 6 bits 1= 1 bit 2= 2 bits 3= 3 bits 4= 4 bits 5= 5 bits 6= 5 bits for R,B and 6 bits for G 7= 3 bits for R,G and 2 bits for B 8= 8 bits, this also forces dither to be disabled. This setting can be used to output 24-bit data in 1-pixel/clock parallel display data format. 0 = BASE666 1 = BASE111 2 = BASE222 3 = BASE333 4 = BASE444 5 = BASE555 6 = BASE565 7 = BASE332 8 = BASE888 */
        unsigned int undefined_bits_4_7:4;
        unsigned int dither_control:2;      /* Dither Control 00= dither disabled 01= reserved 10= ordered dither 11= error-diffusion dither  Design Note: initial dither matrix (where d is 2 dither bits) d=00 d=01 d=10 d=11 --------- --------- --------- ---------  0  0   1  0   0  1   0  1  --------- --------- --------- ---------  0  0   0  0   1  0   1  1  --------- --------- --------- ---------  Note: 0 in the matrix specifies no addition to base color 1 in the matrix specifies incrementation of base color (with saturation) 0 = DISABLE 2 = ORDERED 3 = ERRDIFF */
        unsigned int undefined_bits_10_11:2;
        unsigned int ord_dither_rotation:2; /* Ordered Dither Frame Rotation This parameter specifies the rotation frequency of the dither matrix in terms of number of frames. If programmed to 0, there is no dither matrix rotation. If programmed to N where N is larger than 0, the dither matrix is rotated clockwise every N frame */
        unsigned int undefined_bits_14_15:2;
        unsigned int disp_color_swap:1;     /* Display Color Swap 0= RGB (normal) 1= BGR (red-blue reverse) 0 = RGB 1 = BGR */
        unsigned int blank_color:1;         /* Blank Color 0= zeros 1= ones Non Base Color applies to least significant color bits which are not part of base color and it has higher priority over Border Color but lower priority over Blank color */
        unsigned int non_base_color:1;      /* Non Base Color 0= zeros 1= ones MD0-3 signals are general purpose mode signals that can be output in various pins (see Pin Output Select) to configure the display device. These bits are effective at start of frame. Typically these can be programmed in shadow register which takes effect on the next frame */
        unsigned int undefined_bits_19_23:5;
        unsigned int lcd_md0:1;             /* LCD Mode 0 signal  0 = LOW 1 = HIGH */
        unsigned int lcd_md1:1;             /* LCD Mode 1 signal  0 = LOW 1 = HIGH */
        unsigned int lcd_md2:1;             /* LCD Mode 2 signal  0 = LOW 1 = HIGH */
        unsigned int lcd_md3:1;             /* LCD Mode 3 signal  0 = LOW 1 = HIGH */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} disp_disp_color_control_t;

#define DISP_SHIFT_CLOCK_OPTIONS_OFFSET 0x431
#define DISP_SHIFT_CLOCK_OPTIONS_RESET  0x00000000
typedef union disp_shift_clock_options_u {
    struct {
        unsigned int sc0_h_qualifier:3;     /* SC0 Horizontal Qualifier 0= disable (regardless of vertical qualifier) 1= no horizontal qualifier (V qualifier only) 2= horizontal display active 3= 1-clock early & extended H display active 4= H Pulse 0 (HP0) 5= 1-clock early & extended H Pulse 0 others= reserved 0 = DISABLE 1 = NO_HQUAL 2 = HACTIVE 3 = EXT_HACTIVE 4 = HPULSE0 5 = EXT_HPULSE0 */
        unsigned int sc0_v_qualifier:3;     /* SC0 Vertical Qualifier 0= no vertical qualifier 2= vertical display active 3= 1-line extended vertical display active 4= V Pulse 0 (VP0) 5= 1-line extended V Pulse 0 others= reserved If SC0 is divided by 2 or 4 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of SC0 is generated for the first horizontally qualified 'pixel'. In the case where there is no horizontal qualifier start of horizontal display active will be used to generate the synchronous reset. If Initialization Sequence (IS) is enabled on parallel interface then only divide by 1 is allowed for SC0 Clock Divider and SC0 must have vertical and horizontal qualifiers enabled. 0 = NO_VQUAL 1 = RESERVED 2 = VACTIVE 3 = EXT_VACTIVE 4 = VPULSE0 5 = EXT_VPULSE0 */
        unsigned int sc0_clk_divider:2;     /* SC0 Clock Divider 0= divide by 1 - this is valid for all display interface 1= divide by 2 - this is valid only for 1-pixel/1-clock parallel display and 2-pixel/1-clock parallel display 2= divide by 4 - this is valid only for 1-pixel/1-clock parallel display 3= reserved 0 = DIV1 1 = DIV2 2 = DIV4 */
        unsigned int undefined_bits_8_15:8;
        unsigned int sc1_h_qualifier:3;     /* SC1 Horizontal Qualifier 0= disable (regardless of vertical qualifier) 1= no horizontal qualifier (V qualifier only) 2= horizontal display active 3= 1-clock early & extended H display active 4= H Pulse 1 (HP1) 5= 1-clock early & extended H Pulse 1 others= reserved 0 = DISABLE 1 = NO_HQUAL 2 = HACTIVE 3 = EXT_HACTIVE 4 = HPULSE1 5 = EXT_HPULSE1 */
        unsigned int sc1_v_qualifier:3;     /* SC1 Vertical Qualifier 0= no vertical qualifier 2= vertical display active 3= 1-line extended vertical display active 4= V Pulse 1 (VP1) 5= 1-line extended V Pulse 1 others= reserved If SC1 is divided by 2 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of SC1 is generated for the first horizontally qualified 'pixel'. If SC1 is divided by 4 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of LCD_WR_N is generated for the second horizontally qualified 'pixel'. In the case where there is no horizontal qualifier start of horizontal display active will be used to generate the synchronous reset. If Initialization Sequence (IS) is enabled on parallel interface then only divide by 1 is allowed for SC1 Clock Divider and SC1 must have vertical and horizontal qualifiers enabled. 0 = NO_VQUAL 1 = RESERVED 2 = VACTIVE 3 = EXT_VACTIVE 4 = VPULSE1 5 = EXT_VPULSE1 */
        unsigned int sc1_clk_divider:2;     /* SC1 Clock Divider 0= divide by 1 - this is valid for all display interface 1= divide by 2 - this is valid only for 1-pixel/1-clock parallel display and 2-pixel/1-clock parallel display 2= divide by 4 - this is valid only for 1-pixel/1-clock parallel display 3= reserved 0 = DIV1 1 = DIV2 2 = DIV4 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_shift_clock_options_t;

#define DISP_DATA_ENABLE_OPTIONS_OFFSET 0x432
#define DISP_DATA_ENABLE_OPTIONS_RESET  0x00000000
typedef union disp_data_enable_options_u {
    struct {
        unsigned int de_select:2;           /* DE (Data Enable) vertical coverage control 0= DE is generated on every lines (active & blank) 1= DE is generated only for active lines 2= DE is generated for active lines and Initialization sequence (if IS is enabled). DE is also asserted in the time gap between the IS and the first active line. This bit also controls STH for serial display interface in the same manner. 0 = ACTIVE_BLANK 1 = ACTIVE 2 = ACTIVE_IS */
        unsigned int de_control:3;          /* DE (Data Enable) horizontal coverage control 0= 1-pixel clock pulse preceding active line (1-clock DE) 1= LDE active for horizontal display active time (normal DE) 2= LDE starts 1-pixel clock preceding active line but stays high on horizontal display active (early and extended DE) 3= 1-pixel clock early horizontal display active (early DE) 4= DE is active for the whole line, covering both active data and h blank (active and blank)  0 = ONECLK 1 = NORMAL 2 = EARLY_EXT 3 = EARLY 4 = ACTIVE_BLANK */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} disp_data_enable_options_t;

#define DISP_SERIAL_INTERFACE_OPTIONS_OFFSET 0x433
#define DISP_SERIAL_INTERFACE_OPTIONS_RESET  0x00000000
typedef union disp_serial_interface_options_u {
    struct {
        unsigned int sdt_stp_mode:2;        /* SDT and STP modes 0= SDT and STP disabled 1= reserved 2= SDT & STP enabled, duplicate data sent 3= SDT & STP enabled, duplicate data not sent 0 = DISABLE 1 = RESERVED 2 = ENABLE_DUP 3 = ENABLE */
        unsigned int sdt_stp_duration:4;    /* SDT and STP signal duration 0= 1 shift clock 1= 1 pixel clock 2= 1 pixel clock - 1 shift clock 3= 1 pixel clock - 2 shift clock 4= 1 pixel clock - 3 shift clock 5= 1 pixel clock - 4 shift clock : : : F= 1 pixel clock - 14 shift clock STP active duration is same as SDT if next pixel is not the same as current pixel; else, STP active duration is always 1 pixel clock. Maximum valid setting is pixel clock divider - 1 for pixel clock divider > 4. If pixel clock divider is 4 or less, SDT and STP is always low */
        unsigned int sth_duration:1;        /* STH signal duration 0= STH is high for 1 pixel clock in all cases except for 3-bit 2-channel and 6-bit 3-channel where STH is 1.5 pixel clock and for 3-bit 3-channel STH is 3 pixel clocks. 1= STH is high for 2 pixel clock in all cases except for 3-bit 3-channel STH is 4 pixel clocks. 0 = ONE_CLOCK 1 = TWO_CLOCK */
        unsigned int stp_control:1;         /* STP signal control 0= STP is not OR-ed with H Pulse 2 and vertical blank 1= STP is OR-ed with H Pulse 2 and vertical blank This may be set to 1 when STP needs to be forced high during blank time in which case H Pulse 2 should be programmed when STP needs to be forced high. Vertical blank is the area outside vertical display active. 0 = NORMAL 1 = EXTENDED */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} disp_serial_interface_options_t;

#define DISP_LCD_SPI_OPTIONS_OFFSET 0x434
#define DISP_LCD_SPI_OPTIONS_RESET  0x00000000
typedef union disp_lcd_spi_options_u {
    struct {
        unsigned int lcd_spi_cs:1;          /* LCD SPI Chip Select (SCS_) 0= Send LCD SPI data to Main Display (Main SCS_ is activated) 1= Send LCD SPI data to Sub Display (Sub SCS_ is activated) This bit is also used when SPI Chip Select Control are NOT LCD_IS_SPI to determine either Main SCS_ or Sub SCS_ to be forced active. 0 = MAIN 1 = SUB */
        unsigned int lcd_spi_dc:1;          /* LCD SPI Data/Command (SDC) 0= SPI Data/Command is low for LCD SPI writes to the display. For PCD6 data format, command byte is sent. 1= SPI Data/Command is high for LCD SPI writes to the display. For PCD6 data format, data byte is sent. 0 = LOW 1 = HIGH */
        unsigned int spi_cs_control:2;      /* LCD SPI Chip Select (SCS_) Control for both IS SPI or LCD SPI 0= Main SCS_ or Sub SCS_ is controlled by LCD SPI or by IS SPI 1= Main SCS_ or Sub SCS_ is controlled by LCD SPI, and depending on LCD SPI Chip Select bit, one of them is forced active for 1-line prior to display active when IS SPI is enabled 2= Main SCS_ or Sub SCS_ is controlled by IS SPI, and depending on LCD SPI Chip Select bit, one of them is forced active during vertical display active area when LCD SPI is enabled 3= Main SCS_ or Sub SCS_, depending on LCD SPI Chip Select bit, is forced active 1-line prior to display active when IS SPI is enabled and also during vertical display active area when LCD SPI is enabled 0 = LCD_IS_SPI 1 = LCD_SPI 2 = IS_SPI 3 = FORCED */
        unsigned int lcd_spi_direction:1;   /* LCD SPI Data Direction. Note that data direction does not affect the start byte direction (which is always msb to lsb) and position (always first 8-bit of serial data) for SPI16SB mode. 0 = MSB2LSB 1 = LSB2MSB */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} disp_lcd_spi_options_t;

#define DISP_BORDER_COLOR_OFFSET 0x435
#define DISP_BORDER_COLOR_RESET  0x00000000
typedef union disp_border_color_u {
    struct {
        unsigned int border_color_r:8;      /* Red Border Color */
        unsigned int border_color_g:8;      /* Green Border Color */
        unsigned int border_color_b:8;      /* Blue Border Color */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_border_color_t;

#define DISP_COLOR_KEY0_LOWER_OFFSET 0x436
#define DISP_COLOR_KEY0_LOWER_RESET  0x00000000
typedef union disp_color_key0_lower_u {
    struct {
        unsigned int color_key0_l_r:8;      /* Color Key 0 Red (V) Lower value */
        unsigned int color_key0_l_g:8;      /* Color Key 0 Green (Y) Lower value */
        unsigned int color_key0_l_b:8;      /* Color Key 0 Blue (U) Lower value */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_color_key0_lower_t;

#define DISP_COLOR_KEY0_UPPER_OFFSET 0x437
#define DISP_COLOR_KEY0_UPPER_RESET  0x00000000
typedef union disp_color_key0_upper_u {
    struct {
        unsigned int color_key0_u_r:8;      /* Color Key 0 Red (V) Upper value */
        unsigned int color_key0_u_g:8;      /* Color Key 0 Green (Y) Upper value */
        unsigned int color_key0_u_b:8;      /* Color Key 0 Blue (U) Upper value */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_color_key0_upper_t;

#define DISP_COLOR_KEY1_LOWER_OFFSET 0x438
#define DISP_COLOR_KEY1_LOWER_RESET  0x00000000
typedef union disp_color_key1_lower_u {
    struct {
        unsigned int color_key1_l_r:8;      /* Color Key 1 Red (V) Lower value */
        unsigned int color_key1_l_g:8;      /* Color Key 1 Green (Y) Lower value */
        unsigned int color_key1_l_b:8;      /* Color Key 1 Blue (U) Lower value */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_color_key1_lower_t;

#define DISP_COLOR_KEY1_UPPER_OFFSET 0x439
#define DISP_COLOR_KEY1_UPPER_RESET  0x00000000
typedef union disp_color_key1_upper_u {
    struct {
        unsigned int color_key1_u_r:8;      /* Color Key 1 Red (V) Upper value */
        unsigned int color_key1_u_g:8;      /* Color Key 1 Green (Y) Upper value */
        unsigned int color_key1_u_b:8;      /* Color Key 1 Blue (U) Upper value */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_color_key1_upper_t;

#define DISP_CURSOR_FOREGROUND_OFFSET 0x43C
#define DISP_CURSOR_FOREGROUND_RESET  0x00000000
typedef union disp_cursor_foreground_u {
    struct {
        unsigned int cursor_foreground_r:8; /* Cursor Red Foreground Color */
        unsigned int cursor_foreground_g:8; /* Cursor Green Foreground Color */
        unsigned int cursor_foreground_b:8; /* Cursor Blue Foreground Color */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_cursor_foreground_t;

#define DISP_CURSOR_BACKGROUND_OFFSET 0x43D
#define DISP_CURSOR_BACKGROUND_RESET  0x00000000
typedef union disp_cursor_background_u {
    struct {
        unsigned int cursor_background_r:8; /* Cursor Red Background Color */
        unsigned int cursor_background_g:8; /* Cursor Green Background Color */
        unsigned int cursor_background_b:8; /* Cursor Blue Background Color */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_cursor_background_t;

#define DISP_CURSOR_START_ADDR_OFFSET 0x43E
#define DISP_CURSOR_START_ADDR_RESET  0x00000000
typedef union disp_cursor_start_addr_u {
    struct {
        unsigned int cursor_start_addr:22;  /* Cursor Start Address bits 25:10 */
        unsigned int undefined_bits_22_23:2;
        unsigned int cursor_size:1;         /* Cursor Size 0= 32x32 1= 64x64 0 = C32X32 1 = C64X64 */
        unsigned int undefined_bits_25_27:3;
        unsigned int cursor_clipping:2;     /* Cursor Clipping Select 0 = DISPLAY : 00= display  1 = WA : 01= window A  2 = WB : 10= window B  3 = WC : 11= window C */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_cursor_start_addr_t;

#define DISP_CURSOR_START_ADDR_NS_OFFSET 0x43F
#define DISP_CURSOR_START_ADDR_NS_RESET  0x00000000
typedef union disp_cursor_start_addr_ns_u {
    struct {
        unsigned int cursor_start_addr_ns:22;/* Cursor Start Address bits 25:10 */
        unsigned int undefined_bits_22_23:2;
        unsigned int cursor_size_ns:1;      /* Cursor Size 0= 32x32 1= 64x64 0 = C32X32 1 = C64X64 */
        unsigned int undefined_bits_25_27:3;
        unsigned int cursor_clipping_ns:2;  /* Cursor Clipping Select 0 = DISPLAY : 00= display  1 = WA : 01= window A  2 = WB : 10= window B  3 = WC : 11= window C */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_cursor_start_addr_ns_t;

#define DISP_CURSOR_POSITION_OFFSET 0x440
#define DISP_CURSOR_POSITION_RESET  0x00000000
typedef union disp_cursor_position_u {
    struct {
        unsigned int h_cursor_position:14;  /* H cursor position (signed) */
        unsigned int undefined_bits_14_15:2;
        unsigned int v_cursor_position:14;  /* V cursor position (signed) */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_cursor_position_t;

#define DISP_CURSOR_POSITION_NS_OFFSET 0x441
#define DISP_CURSOR_POSITION_NS_RESET  0x00000000
typedef union disp_cursor_position_ns_u {
    struct {
        unsigned int h_cursor_position_ns:14;/* H cursor position (signed) */
        unsigned int undefined_bits_14_15:2;
        unsigned int v_cursor_position_ns:14;/* V cursor position (signed) */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_cursor_position_ns_t;

#define DISP_INIT_SEQ_CONTROL_OFFSET 0x442
#define DISP_INIT_SEQ_CONTROL_RESET  0x00000000
typedef union disp_init_seq_control_u {
    struct {
        unsigned int send_init_sequence:1;  /* Send Initialization Sequence (IS)  0 = DISABLE 1 = ENABLE */
        unsigned int init_sequence_mode:1;  /* Initialization Sequence Mode 0= Send init sequence through parallel LCD interface 1= Send init sequence through SPI serial interface 0 = PLCD_INIT 1 = SPI_INIT */
        unsigned int undefined_bits_2_3:2;
        unsigned int init_seq_dc_signal:3;  /* Frame Initialization Sequence DC Pin This parameter is used only for parallel initialization sequence and it specifies which signal carries the data/command signal. 0= parallel IS DC signal is not needed 1= parallel IS DC on Vertical Sync 2= parallel IS DC on Vertical Pulse 0 3= parallel IS DC on Vertical Pulse 1 4= parallel IS DC on Vertical Pulse 2 5= parallel IS DC on Vertical Pulse 3 other= reserved 0 = NODC 1 = VSYNC 2 = VPULSE0 3 = VPULSE1 4 = VPULSE2 5 = VPULSE3 */
        unsigned int init_seq_dc_control:1; /* Initialization Sequence DC Pin This bit is used only for parallel initialization sequence and it controls how data/command is added to the vertical signal selected by -=PS_=-INIT_SEQ_DC_SIGNAL 0= parallel IS DC is inverted and then AND-ed to the vertical signal 1= parallel IS DC is OR-ed to the vertical signal */
        unsigned int frame_init_seq_cycles:4;/* Frame Initialization Sequence Cycles This parameter specifies the number of frame initialization sequence cycles to send. If programmed to 0, there is no frame initialization cycle generated */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_init_seq_control_t;

#define DISP_SPI_INIT_SEQ_DATA_A_OFFSET 0x443
#define DISP_SPI_INIT_SEQ_DATA_A_RESET  0x00000000
typedef union disp_spi_init_seq_data_a_u {
    struct {
        unsigned int spi_init_seq_data_a:32;/* SPI Init Sequence Write Data bits 31-0 */
    };

    uint32_t reg32;
} disp_spi_init_seq_data_a_t;

#define DISP_SPI_INIT_SEQ_DATA_B_OFFSET 0x444
#define DISP_SPI_INIT_SEQ_DATA_B_RESET  0x00000000
typedef union disp_spi_init_seq_data_b_u {
    struct {
        unsigned int spi_init_seq_data_b:32;/* SPI Init Sequence Write Data bits 63-32 */
    };

    uint32_t reg32;
} disp_spi_init_seq_data_b_t;

#define DISP_SPI_INIT_SEQ_DATA_C_OFFSET 0x445
#define DISP_SPI_INIT_SEQ_DATA_C_RESET  0x00000000
typedef union disp_spi_init_seq_data_c_u {
    struct {
        unsigned int spi_init_seq_data_c:32;/* SPI Init Sequence Write Data bits 95-64 */
    };

    uint32_t reg32;
} disp_spi_init_seq_data_c_t;

#define DISP_SPI_INIT_SEQ_DATA_D_OFFSET 0x446
#define DISP_SPI_INIT_SEQ_DATA_D_RESET  0x00000000
typedef union disp_spi_init_seq_data_d_u {
    struct {
        unsigned int spi_init_seq_data_d:32;/* SPI Init Sequence Write Data bits 127-96 */
    };

    uint32_t reg32;
} disp_spi_init_seq_data_d_t;

#define DISP_DC_MCCIF_FIFOCTRL_OFFSET 0x480
#define DISP_DC_MCCIF_FIFOCTRL_RESET  0x00000000
typedef union disp_dc_mccif_fifoctrl_u {
    struct {
        unsigned int dc_mccif_wrcl_mcle2x:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int dc_mccif_rdmc_rdfast:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int dc_mccif_wrmc_clle2x:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int dc_mccif_rdcl_rdfast:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} disp_dc_mccif_fifoctrl_t;

#define DISP_MCCIF_DISPLAY0A_HYST_OFFSET 0x481
#define DISP_MCCIF_DISPLAY0A_HYST_RESET  0xCF401F1F
typedef union disp_mccif_display0a_hyst_u {
    struct {
        unsigned int cbr_display0a2mc_hyst_req_tm:8;
        unsigned int cbr_display0a2mc_dhyst_tm:8;
        unsigned int cbr_display0a2mc_dhyst_th:8;
        unsigned int cbr_display0a2mc_hyst_tm:4;
        unsigned int cbr_display0a2mc_hyst_req_th:3;
        unsigned int cbr_display0a2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    uint32_t reg32;
} disp_mccif_display0a_hyst_t;

#define DISP_MCCIF_DISPLAY0B_HYST_OFFSET 0x482
#define DISP_MCCIF_DISPLAY0B_HYST_RESET  0xCF081F1F
typedef union disp_mccif_display0b_hyst_u {
    struct {
        unsigned int cbr_display0b2mc_hyst_req_tm:8;
        unsigned int cbr_display0b2mc_dhyst_tm:8;
        unsigned int cbr_display0b2mc_dhyst_th:8;
        unsigned int cbr_display0b2mc_hyst_tm:4;
        unsigned int cbr_display0b2mc_hyst_req_th:3;
        unsigned int cbr_display0b2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    uint32_t reg32;
} disp_mccif_display0b_hyst_t;

#define DISP_MCCIF_DISPLAY0C_HYST_OFFSET 0x483
#define DISP_MCCIF_DISPLAY0C_HYST_RESET  0xCF081F1F
typedef union disp_mccif_display0c_hyst_u {
    struct {
        unsigned int cbr_display0c2mc_hyst_req_tm:8;
        unsigned int cbr_display0c2mc_dhyst_tm:8;
        unsigned int cbr_display0c2mc_dhyst_th:8;
        unsigned int cbr_display0c2mc_hyst_tm:4;
        unsigned int cbr_display0c2mc_hyst_req_th:3;
        unsigned int cbr_display0c2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    uint32_t reg32;
} disp_mccif_display0c_hyst_t;

#define DISP_MCCIF_DISPLAY1B_HYST_OFFSET 0x484
#define DISP_MCCIF_DISPLAY1B_HYST_RESET  0xCF081F1F
typedef union disp_mccif_display1b_hyst_u {
    struct {
        unsigned int cbr_display1b2mc_hyst_req_tm:8;
        unsigned int cbr_display1b2mc_dhyst_tm:8;
        unsigned int cbr_display1b2mc_dhyst_th:8;
        unsigned int cbr_display1b2mc_hyst_tm:4;
        unsigned int cbr_display1b2mc_hyst_req_th:3;
        unsigned int cbr_display1b2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    uint32_t reg32;
} disp_mccif_display1b_hyst_t;

#define DISP_DAC_CRT_CTRL_OFFSET 0x4C0
#define DISP_DAC_CRT_CTRL_RESET  0x00000000
typedef union disp_dac_crt_ctrl_u {
    struct {
        unsigned int override_notblank:1;   /* If enabled, output display2tvdac_NOTBLANK is tied to 1 0= disable 1= enable 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int sync_select:1;         /* Selects the source for display2tvdac_[hv]sync 0 = VSYNC_HSYNC 1 = LVP0_LHP0 */
        unsigned int undefined_bit_3:1;
        unsigned int notblank_select:1;     /* Selects the source for display2tvdac_notblank 0: notblank = d_active[10] (i.e. data_enable) 1: notblank = (lvp[1] & lhp[1]) 0 = DE 1 = LVP1_LHP1 */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} disp_dac_crt_ctrl_t;

#define DISP_DISP_MISC_CONTROL_OFFSET 0x4C1
#define DISP_DISP_MISC_CONTROL_RESET  0x00000002
typedef union disp_disp_misc_control_u {
    struct {
        unsigned int phase_shift_2p1c18b:1; /* Enable phase shift for 2P1C format phase shift SC0/SC1 will be delayed for one pixel clock cycle. In 2P1C format, data will hold for 2 pixel clocks, so either choice should work 0 = DISABLE 1 = ENABLE */
        unsigned int uf_line_flush:1;       /* Enable underflow line flush, a.o.t end-of-frame flush. underflow line flush  0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} disp_disp_misc_control_t;

#define WINC_A_COLOR_PALETTE_RESET  0x00000000
typedef union winc_a_color_palette_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_a_color_palette_t;

#define WINC_A_PALETTE_COLOR_EXT_RESET  0x00000000
typedef union winc_a_palette_color_ext_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int palette_color_ext:7;   /* Window A Palette Color Extension bits 7-1 are used for 1-bpp mode bits 7-2 are used for 2-bpp mode bits 7-4 are used for 4-bpp mode */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_a_palette_color_ext_t;

#define WIN_A_WIN_OPTIONS_RESET  0x00000000
typedef union win_a_win_options_u {
    struct {
        unsigned int h_direction:1;         /* Window A Horizontal (X) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bit_1:1;
        unsigned int v_direction:1;         /* Window A Vertical (Y) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bits_3_5:3;
        unsigned int color_expand:1;        /* Window A 12/15/16/18-to-24 bpp color expansion This bit should be enabled only for 12-bpp B4G4R4A4, 15-bpp B5G5R5A, 16-bpp B5G6R5, 18-bpp B6G6R6 color modes. If enabled the color conversion is performed prior to horizontal scaling.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_7_15:9;
        unsigned int cp_enable:1;           /* Window A Color Palette Enable This controls the color palette and should be enabled for palletized color modes. For non-palletized color modes, the color palette can be enabled for gamma correction.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_17_19:3;
        unsigned int dv_enable:1;           /* Window A Digital Vibrance Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_29:9;
        unsigned int win_enable:1;          /* Window A Window enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} win_a_win_options_t;

#define WIN_A_BYTE_SWAP_RESET  0x00000000
typedef union win_a_byte_swap_u {
    struct {
        unsigned int byte_swap:2;           /* Window A Byte Swap This controls byte swap of frame data read from memory prior to any data processing in the display module. 00= no byte swap (3 2 1 0) 01= byte swap for each 2-byte word (2 3 0 1) 10= byte swap for each 4-byte word (0 1 2 3) 11= word swap for each 4-byte word (1 0 3 2) 0 = NOSWAP 1 = SWAP2 2 = SWAP4 3 = SWAP4HW */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} win_a_byte_swap_t;

#define WIN_A_BUFFER_CONTROL_RESET  0x00000000
typedef union win_a_buffer_control_u {
    struct {
        unsigned int buffer_control:3;      /* Window A Buffer Control 0= Host (software) controlled 1= Video Input controlled 2= Encoder Pre-Processor controlled 3= MPEG Encoder controlled 4= StretchBLT or 2D other= reserved If window buffer selection is not controlled by host (software) then buffer start indexes are sent by the respective module specified by this parameter, and in this case, the buffer start address registers are used to specify frame stride and buffer offset for the calculated start address. 0 = HOST 1 = VI 2 = EPP 4 = SB2D 3 = MPEGE */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} win_a_buffer_control_t;

#define WIN_A_COLOR_DEPTH_RESET  0x00000000
typedef union win_a_color_depth_u {
    struct {
        unsigned int color_depth:5;         /* Window A Color Depth Supported color depths are: P1 = 1-bpp (palletized) P2 = 2-bpp (palletized) P4 = 4-bpp (palletized) P8 = 8-bpp (palletized) B4G4R4A4 = 12-bpp B4G4R4 B5G5R5A = 15-bpp B5G5R5 AB5G5R5 = 15-bpp B5G5R5 B5G6R5 = 16-bpp B5G6R5 B8G8R8A8 = 32-bpp B8G8R8A8 R8G8B8A8 = 32-bpp R8G8B8A8 B6x2G6x2R6x2A8 = 32-bpp B6G6R6A8 R6x2G6x2B6x2A8 = 32-bpp R6G6B6A8 0 = P1 1 = P2 2 = P4 3 = P8 4 = B4G4R4A4 5 = B5G5R5A 6 = B5G6R5 7 = AB5G5R5 12 = B8G8R8A8 13 = R8G8B8A8 14 = B6x2G6x2R6x2A8 15 = R6x2G6x2B6x2A8 16 = YCbCr422 17 = YUV422 18 = YCbCr420P 19 = YUV420P 20 = YCbCr422P 21 = YUV422P 22 = YCbCr422R 23 = YUV422R 24 = YCbCr422RA 25 = YUV422RA */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} win_a_color_depth_t;

#define WIN_A_POSITION_RESET  0x00000000
typedef union win_a_position_u {
    struct {
        unsigned int h_position:13;         /* Window A H Position This is specified with respect to the left edge of active display area */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_position:13;         /* Window A V Position This is specified with respect to the top edge of active display area */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} win_a_position_t;

#define WIN_A_SIZE_RESET  0x00000000
typedef union win_a_size_u {
    struct {
        unsigned int h_size:13;             /* Window A H Size (pixels) This is the horizontal size after scaling */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_size:13;             /* Window A V Size (lines) This is the vertical size after scaling */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} win_a_size_t;

#define WIN_A_PRESCALED_SIZE_RESET  0x00000000
typedef union win_a_prescaled_size_u {
    struct {
        unsigned int h_prescaled_size:15;   /* Window A H Pre-scaled Size (bytes) In 420P and 422P formats, it must be even */
        unsigned int undefined_bit_15:1;
        unsigned int v_prescaled_size:13;   /* Window A V Pre-scaled Size (lines) In 420P/422R/422RA formats, it must be even */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} win_a_prescaled_size_t;

#define WIN_A_H_INITIAL_DDA_RESET  0x00000000
typedef union win_a_h_initial_dda_u {
    struct {
        unsigned int h_initial_dda:16;      /* Window A H Initial DDA (4.12) This is typically programmed to 0.0 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} win_a_h_initial_dda_t;

#define WIN_A_V_INITIAL_DDA_RESET  0x00000000
typedef union win_a_v_initial_dda_u {
    struct {
        unsigned int v_initial_dda:16;      /* Window A V Initial DDA (4.12) This is typically programmed to 0.0 for both non-interlaced and interlaced sources */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} win_a_v_initial_dda_t;

#define WIN_A_DDA_INCREMENT_RESET  0x00000000
typedef union win_a_dda_increment_u {
    struct {
        unsigned int h_dda_increment:16;    /* Window A Horizontal DDA Increment (4.12) This should be set to 1.0 if there is no scaling. The maximum value for downscaling depends on the number of bytes per pixel. For 4-byte/pixel modes (32-bpp) the maximum value is 4.0 and for all other modes the maximum value is 8.0 */
        unsigned int v_dda_increment:16;    /* Window A Vertical DDA Increment (4.12) This should be set to 1.0 if there is no scaling. Maximum value is 15.0 regardless of the number of bytes per pixel */
    };

    uint32_t reg32;
} win_a_dda_increment_t;

#define WIN_A_LINE_STRIDE_RESET  0x00000000
typedef union win_a_line_stride_u {
    struct {
        unsigned int line_stride:16;        /* Window A Line Stride This is stride (in bytes) for all non-planar data formats. If the memory surface is tiled, the stride needs to be a multiple of 16. If H_DIRECTION of window A is set to DECREMENT, the stride also needs to be a multiple of 16.  For planar YUV or YCbCr data formats, this is stride (in bytes) for the luma plane with the restriction that it must be multiples of 8 (16 if tiled or in horizontal flipping) For tiled surface this value may affect starting address of a window. Refer to the comment of START_ADDR for detail */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} win_a_line_stride_t;

#define WIN_A_BUF_STRIDE_RESET  0x00000000
typedef union win_a_buf_stride_u {
    struct {
        unsigned int buf_stride:32;         /* Window A Buffer stride Buffer stride is used to calculate the buffer addresses when the window is triggered by non-host modules. Refer to the comment of of START_ADDR for programming guide. For YUV planar pixel format, this specifies buffer stride for the Y plane. The value is in bytes */
    };

    uint32_t reg32;
} win_a_buf_stride_t;

#define WIN_A_BUFFER_ADDR_MODE_RESET  0x00000000
typedef union win_a_buffer_addr_mode_u {
    struct {
        unsigned int tile_mode:1;           /* Window A Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the Y plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_1_31:31;
    };

    uint32_t reg32;
} win_a_buffer_addr_mode_t;

#define WIN_A_DV_CONTROL_RESET  0x00000000
typedef union win_a_dv_control_u {
    struct {
        unsigned int dv_control_r:3;        /* Digital Vibrance control for R */
        unsigned int undefined_bits_3_7:5;
        unsigned int dv_control_g:3;        /* Digital Vibrance control for G */
        unsigned int undefined_bits_11_15:5;
        unsigned int dv_control_b:3;        /* Digital Vibrance control for B */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} win_a_dv_control_t;

#define WIN_A_BLEND_NOKEY_RESET  0x00000000
typedef union win_a_blend_nokey_u {
    struct {
        unsigned int blend_control_nokey:1; /* Window blend control for color key not match areas. 0 = Fix weight using window blend weight 0 for color key not matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT; 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_1_7:7;
        unsigned int blend_weight0_nokey:8; /* Window blend weight 0 for color key not match areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_nokey:8; /* Window blend weight 1 for color key not match areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_a_blend_nokey_t;

#define WIN_A_BLEND_1WIN_RESET  0x00000000
typedef union win_a_blend_1win_u {
    struct {
        unsigned int ckey_enable_1win:2;    /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_1win:1;  /* Window blend control in area where it does not overlap with other windows and either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_3_7:5;
        unsigned int blend_weight0_1win:8;  /* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_1win:8;  /* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_a_blend_1win_t;

#define WIN_A_BLEND_2WIN_B_RESET  0x00000000
typedef union win_a_blend_2win_b_u {
    struct {
        unsigned int ckey_enable_2win_b:2;  /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_2win_b:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int blend_weight0_2win_b:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_2win_b:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_a_blend_2win_b_t;

#define WIN_A_BLEND_2WIN_C_RESET  0x00000000
typedef union win_a_blend_2win_c_u {
    struct {
        unsigned int ckey_enable_2win_c:2;  /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_2win_c:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. Only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int blend_weight0_2win_c:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_2win_c:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_a_blend_2win_c_t;

#define WIN_A_BLEND_3WIN_BC_RESET  0x00000000
typedef union win_a_blend_3win_bc_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int blend_control_3win_bc:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight */
        unsigned int undefined_bits_4_7:4;
        unsigned int blend_weight0_3win_bc:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_3win_bc:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_a_blend_3win_bc_t;

#define WIN_A_HP_FETCH_CONTROL_RESET  0x00000000
typedef union win_a_hp_fetch_control_u {
    struct {
        unsigned int cycles_per_word:16;    /* Window A clock cycles per memory fetch word. The value of this field is essentially a measure of the data consumption rate for window A. It is computed as follows: A_CYCLES_PER_WORD = A_DDA_INCREMENT.A_H_DDA_INCREMENT / (bytes per pixel) Note that the format for this value is a fixed-point fractional value with 8 bits of integer precision and 8 bits of fractional precision. In other words, it is an '8.8' number. For example, if there is no scaling of the input image, the DDA increment will be 4096. With 32-bit RGBA pixels there will be 4 bytes per pixel, so CYCLES_PER_WORD will be ... 4096 / 4 = 1024, or 4.0 expressed in the 8.8 format. Any scaling performed on the pixels will change the rate at which pixels are consumed. Scaling up will increase the value of DDA increment and will therefore increase the number of cycles between memory fetches. Conversely, scaling down will decrease the value of DDA increment and memory fetches will occur more frequently */
        unsigned int words_per_line:15;     /* Window A memory fetch words per scan line. This value is in memory fetch words: Multiples of 16 bytes for Tegra 2 Processor Series devices. It is computed as follows: A_WORDS_PER_LINE = (A_SIZE.A_H_SIZE * (bytes per pixel) + 15) >> 4 bytes per pixel is determined by the pixel format */
        unsigned int fetch_info_enable:1;   /* Enables the sending of the Window A fetch information. For compatibility with earlier devices, this defaults to DISABLE. 0 = DISABLE : This bit should be enabled only for 12-bpp  1 = ENABLE */
    };

    uint32_t reg32;
} win_a_hp_fetch_control_t;

#define WINBUF_A_START_ADDR_RESET  0x00000000
typedef union winbuf_a_start_addr_u {
    struct {
        unsigned int start_addr:32;         /* Window A Start Address This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies start address for the Y plane */
    };

    uint32_t reg32;
} winbuf_a_start_addr_t;

#define WINBUF_A_START_ADDR_NS_RESET  0x00000000
typedef union winbuf_a_start_addr_ns_u {
    struct {
        unsigned int start_addr_ns:32;      /* Window A Shadowed Start Address This is ARM set shadow of Start Address */
    };

    uint32_t reg32;
} winbuf_a_start_addr_ns_t;

#define WINBUF_A_ADDR_H_OFFSET_RESET  0x00000000
typedef union winbuf_a_addr_h_offset_u {
    struct {
        unsigned int addr_h_offset:32;      /* Window A Horizontal address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies horizontal offset of Y plane. The horizontal offsets of U/V plane is derived by HW */
    };

    uint32_t reg32;
} winbuf_a_addr_h_offset_t;

#define WINBUF_A_ADDR_H_OFFSET_NS_RESET  0x00000000
typedef union winbuf_a_addr_h_offset_ns_u {
    struct {
        unsigned int addr_h_offset_ns:32;   /* Window A Shadowed Horizontal address offset This is ARM set shadow of ADDR_H_OFFSET */
    };

    uint32_t reg32;
} winbuf_a_addr_h_offset_ns_t;

#define WINBUF_A_ADDR_V_OFFSET_RESET  0x00000000
typedef union winbuf_a_addr_v_offset_u {
    struct {
        unsigned int addr_v_offset:32;      /* Window A Vertical address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies vertical offset of Y plane. The vertical offsets of U/V plane is derived by HW */
    };

    uint32_t reg32;
} winbuf_a_addr_v_offset_t;

#define WINBUF_A_ADDR_V_OFFSET_NS_RESET  0x00000000
typedef union winbuf_a_addr_v_offset_ns_u {
    struct {
        unsigned int addr_v_offset_ns:32;   /* Window A Shadowed Vertical address offset This is ARM set shadow of ADDR_V_OFFSET */
    };

    uint32_t reg32;
} winbuf_a_addr_v_offset_ns_t;

#define WINBUF_A_UFLOW_STATUS_RESET  0x00000000
typedef union winbuf_a_uflow_status_u {
    struct {
        unsigned int uflow_count:24;        /* Underflow count. This field indicates the number of contiguous groups of output pixels for which there was no data in the FIFO. For example, if the valid from the FIFO is low for 10 consecutive cycles and then goes high, the counter will increment by one. Reset to zero on write */
        unsigned int undefined_bits_24_29:6;
        unsigned int count_oflow:1;         /* Flag bit that indicates that the underflow event counter has overflowed. There were too many events. If COUNT_OFLOW is set, UFLOW_COUNT is meaningless. Cleared on write */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} winbuf_a_uflow_status_t;

#define WINC_COLOR_PALETTE_OFFSET 0x500
#define WINC_B_COLOR_PALETTE_RESET  0x00000000
typedef union winc_b_color_palette_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_t;

#define WINC_PALETTE_COLOR_EXT_OFFSET 0x600
#define WINC_B_PALETTE_COLOR_EXT_RESET  0x00000000
typedef union winc_b_palette_color_ext_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int palette_color_ext:7;   /* Window B Palette Color Extension bits 7-1 are used for 1-bpp mode bits 7-2 are used for 2-bpp mode bits 7-4 are used for 4-bpp mode */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_palette_color_ext_t;

#define WINC_H_FILTER_P00_OFFSET 0x601
#define WINC_B_H_FILTER_P00_RESET  0x00000000
typedef union winc_b_h_filter_p00_u {
    struct {
        unsigned int h_filter_p00c0:3;      /* Phase 00 coefficient 0 (typically 0) */
        unsigned int h_filter_p00c1:5;      /* Phase 00 coefficient 1 (typically 0) */
        unsigned int h_filter_p00c2:8;      /* Phase 00 coefficient 2 (typically 128) */
        unsigned int h_filter_p00c3:8;      /* Phase 00 coefficient 3 (typically 0) */
        unsigned int h_filter_p00c4:5;      /* Phase 00 coefficient 4 (typically 0) */
        unsigned int h_filter_p00c5:3;      /* Phase 00 coefficient 5 (typically 0) */
    };

    uint32_t reg32;
} winc_b_h_filter_p00_t;

#define WINC_H_FILTER_P01_OFFSET 0x602
#define WINC_B_H_FILTER_P01_RESET  0x00000000
typedef union winc_b_h_filter_p01_u {
    struct {
        unsigned int h_filter_p01c0:3;      /* Phase 01 coefficient 0 (typically 1) */
        unsigned int h_filter_p01c1:5;      /* Phase 01 coefficient 1 (typically -4) */
        unsigned int h_filter_p01c2:8;      /* Phase 01 coefficient 2 (typically 124) */
        unsigned int h_filter_p01c3:8;      /* Phase 01 coefficient 3 (typically 8) */
        unsigned int h_filter_p01c4:5;      /* Phase 01 coefficient 4 (typically -2) */
        unsigned int h_filter_p01c5:3;      /* Phase 01 coefficient 5 (typically 1) */
    };

    uint32_t reg32;
} winc_b_h_filter_p01_t;

#define WINC_H_FILTER_P02_OFFSET 0x603
#define WINC_B_H_FILTER_P02_RESET  0x00000000
typedef union winc_b_h_filter_p02_u {
    struct {
        unsigned int h_filter_p02c0:3;      /* Phase 02 coefficient 0 (typically 1) */
        unsigned int h_filter_p02c1:5;      /* Phase 02 coefficient 1 (typically -8) */
        unsigned int h_filter_p02c2:8;      /* Phase 02 coefficient 2 (typically 122) */
        unsigned int h_filter_p02c3:8;      /* Phase 02 coefficient 3 (typically 17) */
        unsigned int h_filter_p02c4:5;      /* Phase 02 coefficient 4 (typically -5) */
        unsigned int h_filter_p02c5:3;      /* Phase 02 coefficient 5 (typically 1) */
    };

    uint32_t reg32;
} winc_b_h_filter_p02_t;

#define WINC_H_FILTER_P03_OFFSET 0x604
#define WINC_B_H_FILTER_P03_RESET  0x00000000
typedef union winc_b_h_filter_p03_u {
    struct {
        unsigned int h_filter_p03c0:3;      /* Phase 03 coefficient 0 (typically 2) */
        unsigned int h_filter_p03c1:5;      /* Phase 03 coefficient 1 (typically -11) */
        unsigned int h_filter_p03c2:8;      /* Phase 03 coefficient 2 (typically 115) */
        unsigned int h_filter_p03c3:8;      /* Phase 03 coefficient 3 (typically 27) */
        unsigned int h_filter_p03c4:5;      /* Phase 03 coefficient 4 (typically -7) */
        unsigned int h_filter_p03c5:3;      /* Phase 03 coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_b_h_filter_p03_t;

#define WINC_H_FILTER_P04_OFFSET 0x605
#define WINC_B_H_FILTER_P04_RESET  0x00000000
typedef union winc_b_h_filter_p04_u {
    struct {
        unsigned int h_filter_p04c0:3;      /* Phase 04 coefficient 0 (typically 2) */
        unsigned int h_filter_p04c1:5;      /* Phase 04 coefficient 1 (typically -13) */
        unsigned int h_filter_p04c2:8;      /* Phase 04 coefficient 2 (typically 109) */
        unsigned int h_filter_p04c3:8;      /* Phase 04 coefficient 3 (typically 37) */
        unsigned int h_filter_p04c4:5;      /* Phase 04 coefficient 4 (typically -9) */
        unsigned int h_filter_p04c5:3;      /* Phase 04 coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_b_h_filter_p04_t;

#define WINC_H_FILTER_P05_OFFSET 0x606
#define WINC_B_H_FILTER_P05_RESET  0x00000000
typedef union winc_b_h_filter_p05_u {
    struct {
        unsigned int h_filter_p05c0:3;      /* Phase 05 coefficient 0 (typically 3) */
        unsigned int h_filter_p05c1:5;      /* Phase 05 coefficient 1 (typically -15) */
        unsigned int h_filter_p05c2:8;      /* Phase 05 coefficient 2 (typically 102) */
        unsigned int h_filter_p05c3:8;      /* Phase 05 coefficient 3 (typically 47) */
        unsigned int h_filter_p05c4:5;      /* Phase 05 coefficient 4 (typically -11) */
        unsigned int h_filter_p05c5:3;      /* Phase 05 coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_b_h_filter_p05_t;

#define WINC_H_FILTER_P06_OFFSET 0x607
#define WINC_B_H_FILTER_P06_RESET  0x00000000
typedef union winc_b_h_filter_p06_u {
    struct {
        unsigned int h_filter_p06c0:3;      /* Phase 06 coefficient 0 (typically 3) */
        unsigned int h_filter_p06c1:5;      /* Phase 06 coefficient 1 (typically -15) */
        unsigned int h_filter_p06c2:8;      /* Phase 06 coefficient 2 (typically 94) */
        unsigned int h_filter_p06c3:8;      /* Phase 06 coefficient 3 (typically 56) */
        unsigned int h_filter_p06c4:5;      /* Phase 06 coefficient 4 (typically -13) */
        unsigned int h_filter_p06c5:3;      /* Phase 06 coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_b_h_filter_p06_t;

#define WINC_H_FILTER_P07_OFFSET 0x608
#define WINC_B_H_FILTER_P07_RESET  0x00000000
typedef union winc_b_h_filter_p07_u {
    struct {
        unsigned int h_filter_p07c0:3;      /* Phase 07 coefficient 0 (typically 3) */
        unsigned int h_filter_p07c1:5;      /* Phase 07 coefficient 1 (typically -16) */
        unsigned int h_filter_p07c2:8;      /* Phase 07 coefficient 2 (typically 85) */
        unsigned int h_filter_p07c3:8;      /* Phase 07 coefficient 3 (typically 67) */
        unsigned int h_filter_p07c4:5;      /* Phase 07 coefficient 4 (typically -14) */
        unsigned int h_filter_p07c5:3;      /* Phase 07 coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_b_h_filter_p07_t;

#define WINC_H_FILTER_P08_OFFSET 0x609
#define WINC_B_H_FILTER_P08_RESET  0x00000000
typedef union winc_b_h_filter_p08_u {
    struct {
        unsigned int h_filter_p08c0:3;      /* Phase 08 coefficient 0 (typically 3) */
        unsigned int h_filter_p08c1:5;      /* Phase 08 coefficient 1 (typically -15) */
        unsigned int h_filter_p08c2:8;      /* Phase 08 coefficient 2 (typically 76) */
        unsigned int h_filter_p08c3:8;      /* Phase 08 coefficient 3 (typically 76) */
        unsigned int h_filter_p08c4:5;      /* Phase 08 coefficient 4 (typically -15) */
        unsigned int h_filter_p08c5:3;      /* Phase 08 coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_b_h_filter_p08_t;

#define WINC_H_FILTER_P09_OFFSET 0x60A
#define WINC_B_H_FILTER_P09_RESET  0x00000000
typedef union winc_b_h_filter_p09_u {
    struct {
        unsigned int h_filter_p09c0:3;      /* Phase 09 coefficient 0 (typically 3) */
        unsigned int h_filter_p09c1:5;      /* Phase 09 coefficient 1 (typically -14) */
        unsigned int h_filter_p09c2:8;      /* Phase 09 coefficient 2 (typically 67) */
        unsigned int h_filter_p09c3:8;      /* Phase 09 coefficient 3 (typically 85) */
        unsigned int h_filter_p09c4:5;      /* Phase 09 coefficient 4 (typically -16) */
        unsigned int h_filter_p09c5:3;      /* Phase 09 coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_b_h_filter_p09_t;

#define WINC_H_FILTER_P0A_OFFSET 0x60B
#define WINC_B_H_FILTER_P0A_RESET  0x00000000
typedef union winc_b_h_filter_p0a_u {
    struct {
        unsigned int h_filter_p0ac0:3;      /* Phase 0A coefficient 0 (typically 3) */
        unsigned int h_filter_p0ac1:5;      /* Phase 0A coefficient 1 (typically -13) */
        unsigned int h_filter_p0ac2:8;      /* Phase 0A coefficient 2 (typically 56) */
        unsigned int h_filter_p0ac3:8;      /* Phase 0A coefficient 3 (typically 94) */
        unsigned int h_filter_p0ac4:5;      /* Phase 0A coefficient 4 (typically -15) */
        unsigned int h_filter_p0ac5:3;      /* Phase 0A coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_b_h_filter_p0a_t;

#define WINC_H_FILTER_P0B_OFFSET 0x60C
#define WINC_B_H_FILTER_P0B_RESET  0x00000000
typedef union winc_b_h_filter_p0b_u {
    struct {
        unsigned int h_filter_p0bc0:3;      /* Phase 0B coefficient 0 (typically 2) */
        unsigned int h_filter_p0bc1:5;      /* Phase 0B coefficient 1 (typically -11) */
        unsigned int h_filter_p0bc2:8;      /* Phase 0B coefficient 2 (typically 47) */
        unsigned int h_filter_p0bc3:8;      /* Phase 0B coefficient 3 (typically 102) */
        unsigned int h_filter_p0bc4:5;      /* Phase 0B coefficient 4 (typically -15) */
        unsigned int h_filter_p0bc5:3;      /* Phase 0B coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_b_h_filter_p0b_t;

#define WINC_H_FILTER_P0C_OFFSET 0x60D
#define WINC_B_H_FILTER_P0C_RESET  0x00000000
typedef union winc_b_h_filter_p0c_u {
    struct {
        unsigned int h_filter_p0cc0:3;      /* Phase 0C coefficient 0 (typically 2) */
        unsigned int h_filter_p0cc1:5;      /* Phase 0C coefficient 1 (typically -9) */
        unsigned int h_filter_p0cc2:8;      /* Phase 0C coefficient 2 (typically 37) */
        unsigned int h_filter_p0cc3:8;      /* Phase 0C coefficient 3 (typically 109) */
        unsigned int h_filter_p0cc4:5;      /* Phase 0C coefficient 4 (typically -13) */
        unsigned int h_filter_p0cc5:3;      /* Phase 0C coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_b_h_filter_p0c_t;

#define WINC_H_FILTER_P0D_OFFSET 0x60E
#define WINC_B_H_FILTER_P0D_RESET  0x00000000
typedef union winc_b_h_filter_p0d_u {
    struct {
        unsigned int h_filter_p0dc0:3;      /* Phase 0D coefficient 0 (typically 2) */
        unsigned int h_filter_p0dc1:5;      /* Phase 0D coefficient 1 (typically -7) */
        unsigned int h_filter_p0dc2:8;      /* Phase 0D coefficient 2 (typically 27) */
        unsigned int h_filter_p0dc3:8;      /* Phase 0D coefficient 3 (typically 115) */
        unsigned int h_filter_p0dc4:5;      /* Phase 0D coefficient 4 (typically -11) */
        unsigned int h_filter_p0dc5:3;      /* Phase 0D coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_b_h_filter_p0d_t;

#define WINC_H_FILTER_P0E_OFFSET 0x60F
#define WINC_B_H_FILTER_P0E_RESET  0x00000000
typedef union winc_b_h_filter_p0e_u {
    struct {
        unsigned int h_filter_p0ec0:3;      /* Phase 0E coefficient 0 (typically 1) */
        unsigned int h_filter_p0ec1:5;      /* Phase 0E coefficient 1 (typically -5) */
        unsigned int h_filter_p0ec2:8;      /* Phase 0E coefficient 2 (typically 17) */
        unsigned int h_filter_p0ec3:8;      /* Phase 0E coefficient 3 (typically 122) */
        unsigned int h_filter_p0ec4:5;      /* Phase 0E coefficient 4 (typically -8) */
        unsigned int h_filter_p0ec5:3;      /* Phase 0E coefficient 5 (typically 1) */
    };

    uint32_t reg32;
} winc_b_h_filter_p0e_t;

#define WINC_H_FILTER_P0F_OFFSET 0x610
#define WINC_B_H_FILTER_P0F_RESET  0x00000000
typedef union winc_b_h_filter_p0f_u {
    struct {
        unsigned int h_filter_p0fc0:3;      /* Phase 0F coefficient 0 (typically 1) */
        unsigned int h_filter_p0fc1:5;      /* Phase 0F coefficient 1 (typically -2) */
        unsigned int h_filter_p0fc2:8;      /* Phase 0F coefficient 2 (typically 8) */
        unsigned int h_filter_p0fc3:8;      /* Phase 0F coefficient 3 (typically 124) */
        unsigned int h_filter_p0fc4:5;      /* Phase 0F coefficient 4 (typically -4) */
        unsigned int h_filter_p0fc5:3;      /* Phase 0F coefficient 5 (typically 1) */
    };

    uint32_t reg32;
} winc_b_h_filter_p0f_t;

#define WINC_CSC_YOF_OFFSET 0x611
#define WINC_B_CSC_YOF_RESET  0x00000000
typedef union winc_b_csc_yof_u {
    struct {
        unsigned int csc_yof:8;             /* Y Offset in s.7.0 format */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_csc_yof_t;

#define WINC_CSC_KYRGB_OFFSET 0x612
#define WINC_B_CSC_KYRGB_RESET  0x00000000
typedef union winc_b_csc_kyrgb_u {
    struct {
        unsigned int csc_kyrgb:10;          /* Y Gain for R, G, B colors in 2.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} winc_b_csc_kyrgb_t;

#define WINC_CSC_KUR_OFFSET 0x613
#define WINC_B_CSC_KUR_RESET  0x00000000
typedef union winc_b_csc_kur_u {
    struct {
        unsigned int csc_kur:11;            /* U coefficients for R in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} winc_b_csc_kur_t;

#define WINC_CSC_KVR_OFFSET 0x614
#define WINC_B_CSC_KVR_RESET  0x00000000
typedef union winc_b_csc_kvr_u {
    struct {
        unsigned int csc_kvr:11;            /* V coefficients for R in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} winc_b_csc_kvr_t;

#define WINC_CSC_KUG_OFFSET 0x615
#define WINC_B_CSC_KUG_RESET  0x00000000
typedef union winc_b_csc_kug_u {
    struct {
        unsigned int csc_kug:10;            /* U coefficients for G in s.1.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} winc_b_csc_kug_t;

#define WINC_CSC_KVG_OFFSET 0x616
#define WINC_B_CSC_KVG_RESET  0x00000000
typedef union winc_b_csc_kvg_u {
    struct {
        unsigned int csc_kvg:10;            /* V coefficients for G in s.1.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} winc_b_csc_kvg_t;

#define WINC_CSC_KUB_OFFSET 0x617
#define WINC_B_CSC_KUB_RESET  0x00000000
typedef union winc_b_csc_kub_u {
    struct {
        unsigned int csc_kub:11;            /* U coefficients for B in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} winc_b_csc_kub_t;

#define WINC_CSC_KVB_OFFSET 0x618
#define WINC_B_CSC_KVB_RESET  0x00000000
typedef union winc_b_csc_kvb_u {
    struct {
        unsigned int csc_kvb:11;            /* V coefficients for B in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} winc_b_csc_kvb_t;

#define WINC_V_FILTER_P00_OFFSET 0x619
#define WINC_B_V_FILTER_P00_RESET  0x00000000
typedef union winc_b_v_filter_p00_u {
    struct {
        unsigned int v_filter_p00c0:8;      /* Phase 00 coefficient 0 (typically 128) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p00_t;

#define WINC_V_FILTER_P01_OFFSET 0x61A
#define WINC_B_V_FILTER_P01_RESET  0x00000000
typedef union winc_b_v_filter_p01_u {
    struct {
        unsigned int v_filter_p01c0:8;      /* Phase 01 coefficient 0 (typically 120) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p01_t;

#define WINC_V_FILTER_P02_OFFSET 0x61B
#define WINC_B_V_FILTER_P02_RESET  0x00000000
typedef union winc_b_v_filter_p02_u {
    struct {
        unsigned int v_filter_p02c0:8;      /* Phase 02 coefficient 0 (typically 112) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p02_t;

#define WINC_V_FILTER_P03_OFFSET 0x61C
#define WINC_B_V_FILTER_P03_RESET  0x00000000
typedef union winc_b_v_filter_p03_u {
    struct {
        unsigned int v_filter_p03c0:8;      /* Phase 03 coefficient 0 (typically 104) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p03_t;

#define WINC_V_FILTER_P04_OFFSET 0x61D
#define WINC_B_V_FILTER_P04_RESET  0x00000000
typedef union winc_b_v_filter_p04_u {
    struct {
        unsigned int v_filter_p04c0:8;      /* Phase 04 coefficient 0 (typically 96) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p04_t;

#define WINC_V_FILTER_P05_OFFSET 0x61E
#define WINC_B_V_FILTER_P05_RESET  0x00000000
typedef union winc_b_v_filter_p05_u {
    struct {
        unsigned int v_filter_p05c0:8;      /* Phase 05 coefficient 0 (typically 88) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p05_t;

#define WINC_V_FILTER_P06_OFFSET 0x61F
#define WINC_B_V_FILTER_P06_RESET  0x00000000
typedef union winc_b_v_filter_p06_u {
    struct {
        unsigned int v_filter_p06c0:8;      /* Phase 06 coefficient 0 (typically 80) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p06_t;

#define WINC_V_FILTER_P07_OFFSET 0x620
#define WINC_B_V_FILTER_P07_RESET  0x00000000
typedef union winc_b_v_filter_p07_u {
    struct {
        unsigned int v_filter_p07c0:8;      /* Phase 07 coefficient 0 (typically 72) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p07_t;

#define WINC_V_FILTER_P08_OFFSET 0x621
#define WINC_B_V_FILTER_P08_RESET  0x00000000
typedef union winc_b_v_filter_p08_u {
    struct {
        unsigned int v_filter_p08c0:8;      /* Phase 08 coefficient 0 (typically 64) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p08_t;

#define WINC_V_FILTER_P09_OFFSET 0x622
#define WINC_B_V_FILTER_P09_RESET  0x00000000
typedef union winc_b_v_filter_p09_u {
    struct {
        unsigned int v_filter_p09c0:8;      /* Phase 09 coefficient 0 (typically 56) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p09_t;

#define WINC_V_FILTER_P0A_OFFSET 0x623
#define WINC_B_V_FILTER_P0A_RESET  0x00000000
typedef union winc_b_v_filter_p0a_u {
    struct {
        unsigned int v_filter_p0ac0:8;      /* Phase 0A coefficient 0 (typically 48) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p0a_t;

#define WINC_V_FILTER_P0B_OFFSET 0x624
#define WINC_B_V_FILTER_P0B_RESET  0x00000000
typedef union winc_b_v_filter_p0b_u {
    struct {
        unsigned int v_filter_p0bc0:8;      /* Phase 0B coefficient 0 (typically 40) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p0b_t;

#define WINC_V_FILTER_P0C_OFFSET 0x625
#define WINC_B_V_FILTER_P0C_RESET  0x00000000
typedef union winc_b_v_filter_p0c_u {
    struct {
        unsigned int v_filter_p0cc0:8;      /* Phase 0C coefficient 0 (typically 32) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p0c_t;

#define WINC_V_FILTER_P0D_OFFSET 0x626
#define WINC_B_V_FILTER_P0D_RESET  0x00000000
typedef union winc_b_v_filter_p0d_u {
    struct {
        unsigned int v_filter_p0dc0:8;      /* Phase 0D coefficient 0 (typically 24) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p0d_t;

#define WINC_V_FILTER_P0E_OFFSET 0x627
#define WINC_B_V_FILTER_P0E_RESET  0x00000000
typedef union winc_b_v_filter_p0e_u {
    struct {
        unsigned int v_filter_p0ec0:8;      /* Phase 0E coefficient 0 (typically 16) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p0e_t;

#define WINC_V_FILTER_P0F_OFFSET 0x628
#define WINC_B_V_FILTER_P0F_RESET  0x00000000
typedef union winc_b_v_filter_p0f_u {
    struct {
        unsigned int v_filter_p0fc0:8;      /* Phase 0F coefficient 0 (typically 8) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_b_v_filter_p0f_t;

#define WIN_WIN_OPTIONS_OFFSET 0x700
#define WIN_B_WIN_OPTIONS_RESET  0x00000000
typedef union win_b_win_options_u {
    struct {
        unsigned int h_direction:1;         /* Window B Horizontal (X) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bit_1:1;
        unsigned int v_direction:1;         /* Window B Vertical (Y) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bits_3_5:3;
        unsigned int color_expand:1;        /* Window B 12/15/16/18-to-24 bpp color expansion This bit should be enabled only for 12-bpp B4G4R4A4, 15-bpp B5G5R5A, 16-bpp B5G6R5, 18-bpp B6G6R6 color modes. If enabled the color conversion is performed prior to horizontal scaling.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int h_filter_enable:1;     /* Window B H Filter Enable This controls H scaling filter and is effective only for non-palletized color modes.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int v_filter_enable:1;     /* Window B V Filter Enable This controls V scaling filter and is effective only for non-palletized color modes. If V filter is disabled, only one line is read from memory for each output line.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int v_filter_optimize:1;   /* Window B V Filter Optimization This is effective only when vertical scaling filter is enabled. This can be used (enabled) to temporarily disable the vertical scaling filter when the vertical scaling DDA fraction is zero. In this case the next line is not fetched from memory to save bandwidth and power. This feature cannot be used in 420P/422R/422RA formats.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_13:1;
        unsigned int v_filter_uv_align:1;   /* Window B V Filter UV Alignment This is effective only when vertical scaling filter is enabled and only on these formats YCbCr420P, YUV420P, YCbCr422R, YUV422R, YCbCr422RA YUV422RA. When UV alignment is enabled, the chroma components are aligned to the even number of luma component lines. When disabled the chroma components are aligned to half a pixel below the corresponding even number of luma component lines. It is usually disabled unless the incoming video stream specifically indicates otherwise.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_15:1;
        unsigned int cp_enable:1;           /* Window B Color Palette Enable This controls the color palette and should be enabled for palletized color modes. For non-palletized color modes, the color palette can be enabled for gamma correction.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int csc_enable:1;          /* Window B Color Space Conversion Enable This controls the color space conversion and should be enabled for YCbCr/YUV color modes for conversion to B8G8R8 and for hue and saturation control. This can also be used for gain control for RGB color modes  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int dv_enable:1;           /* Window B Digital Vibrance Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int yuv_range_expand:1;    /* Window B Enable range expansion in the cases where RANGEREDFRM is 1 from mpd. Formula: Y = clip(( Y-128)*2 + 128); Cb = clip((Cb-128)*2 + 128); Cr = clip((Cr-128)*2 + 128); where clip() function clips between 0 and 255. 0= disable 1= enable 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_23_29:7;
        unsigned int win_enable:1;          /* Window B Window enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} win_b_win_options_t;

#define WIN_BYTE_SWAP_OFFSET 0x701
#define WIN_B_BYTE_SWAP_RESET  0x00000000
typedef union win_b_byte_swap_u {
    struct {
        unsigned int byte_swap:2;           /* Window B Byte Swap This controls byte swap of frame data read from memory prior to any data processing in the display module. 00= no byte swap (3 2 1 0) 01= byte swap for each 2-byte word (2 3 0 1) 10= byte swap for each 4-byte word (0 1 2 3) 11= word swap for each 4-byte word (1 0 3 2) 0 = NOSWAP 1 = SWAP2 2 = SWAP4 3 = SWAP4HW */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} win_b_byte_swap_t;

#define WIN_BUFFER_CONTROL_OFFSET 0x702
#define WIN_B_BUFFER_CONTROL_RESET  0x00000000
typedef union win_b_buffer_control_u {
    struct {
        unsigned int buffer_control:3;      /* Window B Buffer Control 0= Host (software) controlled 1= Video Input controlled 2= Encoder Pre-Processor controlled 3= MPEG Encoder controlled 4= StretchBLT or 2D other= reserved If window buffer selection is not controlled by host (software) then buffer start indexes are sent by the respective module specified by this parameter, and in this case, the buffer start address registers are used to specify frame stride and buffer offset for the calculated start address. 0 = HOST 1 = VI 2 = EPP 4 = SB2D 3 = MPEGE */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} win_b_buffer_control_t;

#define WIN_COLOR_DEPTH_OFFSET 0x703
#define WIN_B_COLOR_DEPTH_RESET  0x00000000
typedef union win_b_color_depth_u {
    struct {
        unsigned int color_depth:5;         /* Window B Color Depth Supported color depths are: P8 = 8-bpp (palletized) B4G4R4A4 = 12-bpp B4G4R4 B5G5R5A = 15-bpp B5G5R5 AB5G5R5 = 15-bpp B5G5R5 B5G6R5 = 16-bpp B5G6R5 B8G8R8A8 = 32-bpp B8G8R8A8 R8G8B8A8 = 32-bpp R8G8B8A8 B6x2G6x2R6x2A8 = 32-bpp B6G6R6A8 R6x2G6x2B6x2A8 = 32-bpp R6G6B6A8 YCbCr422 = 16-bpp YCbCr422 packed YUV422 = 16-bpp YUV422 YCbCr420P = 16-bpp YCbCr420 planar YUV420P = 16-bpp YUV420 planar YCbCr422P = 16-bpp YCbCr422 planar YUV422P = 16-bpp YUV422 planar YCbCr422R = 16-bpp YCbCr422 rotated planar YUV422R = 16-bpp YUV422 rotated planar YCbCr422RA= 16-bpp YCbCr422 rotated planar with chroma averaging YUV422RA = 16-bpp YUV422 rotated planar with chroma averaging 0 = P1 1 = P2 2 = P4 3 = P8 4 = B4G4R4A4 5 = B5G5R5A 6 = B5G6R5 7 = AB5G5R5 12 = B8G8R8A8 13 = R8G8B8A8 14 = B6x2G6x2R6x2A8 15 = R6x2G6x2B6x2A8 16 = YCbCr422 17 = YUV422 18 = YCbCr420P 19 = YUV420P 20 = YCbCr422P 21 = YUV422P 22 = YCbCr422R 23 = YUV422R 24 = YCbCr422RA 25 = YUV422RA */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} win_b_color_depth_t;

#define WIN_POSITION_OFFSET 0x704
#define WIN_B_POSITION_RESET  0x00000000
typedef union win_b_position_u {
    struct {
        unsigned int h_position:13;         /* Window B H Position This is specified with respect to the left edge of active display area */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_position:13;         /* Window B V Position This is specified with respect to the top edge of active display area */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} win_b_position_t;

#define WIN_SIZE_OFFSET 0x705
#define WIN_B_SIZE_RESET  0x00000000
typedef union win_b_size_u {
    struct {
        unsigned int h_size:13;             /* Window B H Size (pixels) This is the horizontal size after scaling */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_size:13;             /* Window B V Size (lines) This is the vertical size after scaling */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} win_b_size_t;

#define WIN_PRESCALED_SIZE_OFFSET 0x706
#define WIN_B_PRESCALED_SIZE_RESET  0x00000000
typedef union win_b_prescaled_size_u {
    struct {
        unsigned int h_prescaled_size:15;   /* Window B H Pre-scaled Size (bytes) In 420P and 422P formats, it must be even */
        unsigned int undefined_bit_15:1;
        unsigned int v_prescaled_size:13;   /* Window B V Pre-scaled Size (lines) In 420P/422R/422RA formats, it must be even */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} win_b_prescaled_size_t;

#define WIN_H_INITIAL_DDA_OFFSET 0x707
#define WIN_B_H_INITIAL_DDA_RESET  0x00000000
typedef union win_b_h_initial_dda_u {
    struct {
        unsigned int h_initial_dda:16;      /* Window B H Initial DDA (4.12) This is typically programmed to 0.0 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} win_b_h_initial_dda_t;

#define WIN_V_INITIAL_DDA_OFFSET 0x708
#define WIN_B_V_INITIAL_DDA_RESET  0x00000000
typedef union win_b_v_initial_dda_u {
    struct {
        unsigned int v_initial_dda:16;      /* Window B V Initial DDA (4.12) This is typically programmed to 0.0 for both non-interlaced and interlaced sources */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} win_b_v_initial_dda_t;

#define WIN_DDA_INCREMENT_OFFSET 0x709
#define WIN_B_DDA_INCREMENT_RESET  0x00000000
typedef union win_b_dda_increment_u {
    struct {
        unsigned int h_dda_increment:16;    /* Window B Horizontal DDA Increment (4.12) This should be set to 1.0 if there is no scaling. The maximum value for downscaling depends on the number of bytes per pixel. For 4-byte/pixel modes (32-bpp) the maximum value is 4.0 and for all other modes the maximum value is 8.0 */
        unsigned int v_dda_increment:16;    /* Window B Vertical DDA Increment (4.12) This should be set to 1.0 if there is no scaling. Maximum value is 15.0 regardless of the number of bytes per pixel */
    };

    uint32_t reg32;
} win_b_dda_increment_t;

#define WIN_LINE_STRIDE_OFFSET 0x70A
#define WIN_B_LINE_STRIDE_RESET  0x00000000
typedef union win_b_line_stride_u {
    struct {
        unsigned int line_stride:16;        /* Window B Line Stride This is stride (in bytes) for all non-planar data formats. If the memory surface is tiled, the stride needs to be a multiple of 16. If H_DIRECTION of window B is set to DECREMENT, the stride also needs to be a multiple of 16. For planar YUV or YCbCr data formats, this is stride (in bytes) for the luma plane with the restriction that it must be multiples of 8 (16 if tiled or in horizontal flipping) For tiled surface this value may affect starting address of a window. Refer to the comment of START_ADDR for detail */
        unsigned int uv_line_stride:16;     /* Window B Line Stride for Chroma This is stride (in bytes) for planar YUV or YCbCr data formats for the chroma plane, with the restriction that it must be programmed to be multiples of 4 (16 if tiled or in horizontal flipping) This is not used (ignored) for other non-planar data formats */
    };

    uint32_t reg32;
} win_b_line_stride_t;

#define WIN_BUF_STRIDE_OFFSET 0x70B
#define WIN_B_BUF_STRIDE_RESET  0x00000000
typedef union win_b_buf_stride_u {
    struct {
        unsigned int buf_stride:32;         /* Window B Buffer stride Buffer stride is used to calculate the buffer addresses when the window is triggered by non-host modules. Refer to the comment of of START_ADDR for programming guide. For YUV planar pixel format, this specifies buffer stride for the Y plane. The value is in bytes */
    };

    uint32_t reg32;
} win_b_buf_stride_t;

#define WIN_UV_BUF_STRIDE_OFFSET 0x70C
#define WIN_B_UV_BUF_STRIDE_RESET  0x00000000
typedef union win_b_uv_buf_stride_u {
    struct {
        unsigned int uv_buf_stride:32;      /* Window B This value is in bytes. For YUV planar pixel format, this specifies buffer stride for the U/V plane */
    };

    uint32_t reg32;
} win_b_uv_buf_stride_t;

#define WIN_BUFFER_ADDR_MODE_OFFSET 0x70D
#define WIN_B_BUFFER_ADDR_MODE_RESET  0x00000000
typedef union win_b_buffer_addr_mode_u {
    struct {
        unsigned int tile_mode:1;           /* Window B Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the Y plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_1_15:15;
        unsigned int uv_tile_mode:1;        /* Window B Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the U/V plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_17_31:15;
    };

    uint32_t reg32;
} win_b_buffer_addr_mode_t;

#define WIN_DV_CONTROL_OFFSET 0x70E
#define WIN_B_DV_CONTROL_RESET  0x00000000
typedef union win_b_dv_control_u {
    struct {
        unsigned int dv_control_r:3;        /* Digital Vibrance control for R */
        unsigned int undefined_bits_3_7:5;
        unsigned int dv_control_g:3;        /* Digital Vibrance control for G */
        unsigned int undefined_bits_11_15:5;
        unsigned int dv_control_b:3;        /* Digital Vibrance control for B */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} win_b_dv_control_t;

#define WIN_BLEND_NOKEY_OFFSET 0x70F
#define WIN_B_BLEND_NOKEY_RESET  0x00000000
typedef union win_b_blend_nokey_u {
    struct {
        unsigned int blend_control_nokey:1; /* Window blend control for color key not match areas. 0 = Fix weight using window blend weight 0 for color key not matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_1_7:7;
        unsigned int blend_weight0_nokey:8; /* Window blend weight 0 for color key not match areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_nokey:8; /* Window blend weight 1 for color key not match areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_b_blend_nokey_t;

#define WIN_BLEND_1WIN_OFFSET 0x710
#define WIN_B_BLEND_1WIN_RESET  0x00000000
typedef union win_b_blend_1win_u {
    struct {
        unsigned int ckey_enable_1win:2;    /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_1win:1;  /* Window blend control in area where it does not overlap with other windows and either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_3_7:5;
        unsigned int blend_weight0_1win:8;  /* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_1win:8;  /* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_b_blend_1win_t;

#define WIN_BLEND_2WIN_X_OFFSET 0x711
#define WIN_B_BLEND_2WIN_A_RESET  0x00000000
typedef union win_b_blend_2win_a_u {
    struct {
        unsigned int ckey_enable_2win_a:2;  /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_2win_a:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int blend_weight0_2win_a:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_2win_a:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_b_blend_2win_a_t;

#define WIN_BLEND_2WIN_Y_OFFSET 0x712
#define WIN_B_BLEND_2WIN_C_RESET  0x00000000
typedef union win_b_blend_2win_c_u {
    struct {
        unsigned int ckey_enable_2win_c:2;  /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_2win_c:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int blend_weight0_2win_c:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_2win_c:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_b_blend_2win_c_t;

#define WIN_BLEND_3WIN_XY_OFFSET 0x713
#define WIN_B_BLEND_3WIN_AC_RESET  0x00000000
typedef union win_b_blend_3win_ac_u {
    struct {
        unsigned int ckey_enable_3win_ac:2; /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_3win_ac:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int blend_weight0_3win_ac:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_3win_ac:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_b_blend_3win_ac_t;

#define WIN_HP_FETCH_CONTROL_OFFSET 0x714
#define WIN_B_HP_FETCH_CONTROL_RESET  0x00000000
typedef union win_b_hp_fetch_control_u {
    struct {
        unsigned int cycles_per_word:16;    /* Window B clock cycles per memory fetch word. The value of this field is essentially a measure of the data consumption rate for window B. It is computed as follows: B_CYCLES_PER_WORD = B_DDA_INCREMENT.B_H_DDA_INCREMENT / (bytes per pixel) Note that the format for this value is a fixed-point fractional value with 8 bits of integer precision and 8 bits of fractional precision. In other words, it is an '8.8' number. For example, if there is no scaling of the input image, the DDA increment will be 4096. With 32-bit RGBA pixels there will be 4 bytes per pixel, so CYCLES_PER_WORD will be ... 4096 / 4 = 1024, or 4.0 expressed in the 8.8 format. Any scaling performed on the pixels will change the rate at which pixels are consumed. Scaling up will increase the value of DDA increment and will therefore increase the number of cycles between memory fetches. Conversely, scaling down will decrease the value of DDA increment and memory fetches will occur more frequently */
        unsigned int words_per_line:15;     /* Window B memory fetch words per scan line. This value is in memory fetch words: Multiples of 16 bytes for Tegra 2 Processor Series devices. It is computed as follows: B_WORDS_PER_LINE = (B_SIZE.B_H_SIZE * (bytes per pixel) + 15) >> 4 bytes per pixel is determined by the pixel format */
        unsigned int fetch_info_enable:1;   /* Enables the sending of the Window B fetch information. For compatibility with earlier devices, this defaults to DISABLE. 0 = DISABLE : This bit should be enabled only for 12-bpp  1 = ENABLE */
    };

    uint32_t reg32;
} win_b_hp_fetch_control_t;

#define WINBUF_START_ADDR_OFFSET 0x800
#define WINBUF_B_START_ADDR_RESET  0x00000000
typedef union winbuf_b_start_addr_u {
    struct {
        unsigned int start_addr:32;         /* Window B Start Address This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies start address for the Y plane */
    };

    uint32_t reg32;
} winbuf_b_start_addr_t;

#define WINBUF_START_ADDR_NS_OFFSET 0x801
#define WINBUF_B_START_ADDR_NS_RESET  0x00000000
typedef union winbuf_b_start_addr_ns_u {
    struct {
        unsigned int start_addr_ns:32;      /* Window B Shadowed Start Address This is ARM set shadow of Start Address */
    };

    uint32_t reg32;
} winbuf_b_start_addr_ns_t;

#define WINBUF_START_ADDR_U_OFFSET 0x802
#define WINBUF_B_START_ADDR_U_RESET  0x00000000
typedef union winbuf_b_start_addr_u_u {
    struct {
        unsigned int start_addr_u:32;       /* Window B Start Address for U plane This is a byte address */
    };

    uint32_t reg32;
} winbuf_b_start_addr_u_t;

#define WINBUF_START_ADDR_U_NS_OFFSET 0x803
#define WINBUF_B_START_ADDR_U_NS_RESET  0x00000000
typedef union winbuf_b_start_addr_u_ns_u {
    struct {
        unsigned int start_addr_u_ns:32;    /* Window B Shadowed Start Address for U plane This is ARM set shadow register of U start address */
    };

    uint32_t reg32;
} winbuf_b_start_addr_u_ns_t;

#define WINBUF_START_ADDR_V_OFFSET 0x804
#define WINBUF_B_START_ADDR_V_RESET  0x00000000
typedef union winbuf_b_start_addr_v_u {
    struct {
        unsigned int start_addr_v:32;       /* Window B Start Address for V plane This is a byte address */
    };

    uint32_t reg32;
} winbuf_b_start_addr_v_t;

#define WINBUF_START_ADDR_V_NS_OFFSET 0x805
#define WINBUF_B_START_ADDR_V_NS_RESET  0x00000000
typedef union winbuf_b_start_addr_v_ns_u {
    struct {
        unsigned int start_addr_v_ns:32;    /* Window B Shadowed Start Address for V plane This is ARM set shadow register of U start address */
    };

    uint32_t reg32;
} winbuf_b_start_addr_v_ns_t;

#define WINBUF_ADDR_H_OFFSET_OFFSET 0x806
#define WINBUF_B_ADDR_H_OFFSET_RESET  0x00000000
typedef union winbuf_b_addr_h_offset_u {
    struct {
        unsigned int addr_h_offset:32;      /* Window B Horizontal address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format.  For YUV planar pixel format, this specifies horizontal offset of Y plane. The horizontal offsets of U/V plane is derived by HW */
    };

    uint32_t reg32;
} winbuf_b_addr_h_offset_t;

#define WINBUF_ADDR_H_OFFSET_NS_OFFSET 0x807
#define WINBUF_B_ADDR_H_OFFSET_NS_RESET  0x00000000
typedef union winbuf_b_addr_h_offset_ns_u {
    struct {
        unsigned int addr_h_offset_ns:32;   /* Window B Shadowed Horizontal address offset This is ARM set shadow of ADDR_H_OFFSET */
    };

    uint32_t reg32;
} winbuf_b_addr_h_offset_ns_t;

#define WINBUF_ADDR_V_OFFSET_OFFSET 0x808
#define WINBUF_B_ADDR_V_OFFSET_RESET  0x00000000
typedef union winbuf_b_addr_v_offset_u {
    struct {
        unsigned int addr_v_offset:32;      /* Window B Vertical address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format.  For YUV planar pixel format, this specifies vertical offset of Y plane. Vertical offsets of U/V plane is derived by HW */
    };

    uint32_t reg32;
} winbuf_b_addr_v_offset_t;

#define WINBUF_ADDR_V_OFFSET_NS_OFFSET 0x809
#define WINBUF_B_ADDR_V_OFFSET_NS_RESET  0x00000000
typedef union winbuf_b_addr_v_offset_ns_u {
    struct {
        unsigned int addr_v_offset_ns:32;   /* Window B Shadowed Vertical address offset This is ARM set shadow of ADDR_V_OFFSET */
    };

    uint32_t reg32;
} winbuf_b_addr_v_offset_ns_t;

#define WINBUF_UFLOW_STATUS_OFFSET 0x80A
#define WINBUF_B_UFLOW_STATUS_RESET  0x00000000
typedef union winbuf_b_uflow_status_u {
    struct {
        unsigned int uflow_count:24;        /* Underflow count. This field indicates the number of contiguous groups of output pixels for which there was no data in the FIFO. For example, if the valid from the FIFO is low for 10 consecutive cycles and then goes high, the counter will increment by one. Reset to zero on write */
        unsigned int undefined_bits_24_29:6;
        unsigned int count_oflow:1;         /* Flag bit that indicates that the underflow event counter has overflowed. There were too many events. If COUNT_OFLOW is set, UFLOW_COUNT is meaningless. Cleared on write */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} winbuf_b_uflow_status_t;

#define WINC_C_COLOR_PALETTE_RESET  0x00000000
typedef union winc_c_color_palette_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_c_color_palette_t;

#define WINC_C_PALETTE_COLOR_EXT_RESET  0x00000000
typedef union winc_c_palette_color_ext_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int palette_color_ext:7;   /* Window C Palette Color Extension bits 7-1 are used for 1-bpp mode bits 7-2 are used for 2-bpp mode bits 7-4 are used for 4-bpp mode */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_c_palette_color_ext_t;

#define WINC_C_H_FILTER_P00_RESET  0x00000000
typedef union winc_c_h_filter_p00_u {
    struct {
        unsigned int h_filter_p00c0:3;      /* Phase 00 coefficient 0 (typically 0) */
        unsigned int h_filter_p00c1:5;      /* Phase 00 coefficient 1 (typically 0) */
        unsigned int h_filter_p00c2:8;      /* Phase 00 coefficient 2 (typically 128) */
        unsigned int h_filter_p00c3:8;      /* Phase 00 coefficient 3 (typically 0) */
        unsigned int h_filter_p00c4:5;      /* Phase 00 coefficient 4 (typically 0) */
        unsigned int h_filter_p00c5:3;      /* Phase 00 coefficient 5 (typically 0) */
    };

    uint32_t reg32;
} winc_c_h_filter_p00_t;

#define WINC_C_H_FILTER_P01_RESET  0x00000000
typedef union winc_c_h_filter_p01_u {
    struct {
        unsigned int h_filter_p01c0:3;      /* Phase 01 coefficient 0 (typically 1) */
        unsigned int h_filter_p01c1:5;      /* Phase 01 coefficient 1 (typically -4) */
        unsigned int h_filter_p01c2:8;      /* Phase 01 coefficient 2 (typically 124) */
        unsigned int h_filter_p01c3:8;      /* Phase 01 coefficient 3 (typically 8) */
        unsigned int h_filter_p01c4:5;      /* Phase 01 coefficient 4 (typically -2) */
        unsigned int h_filter_p01c5:3;      /* Phase 01 coefficient 5 (typically 1) */
    };

    uint32_t reg32;
} winc_c_h_filter_p01_t;

#define WINC_C_H_FILTER_P02_RESET  0x00000000
typedef union winc_c_h_filter_p02_u {
    struct {
        unsigned int h_filter_p02c0:3;      /* Phase 02 coefficient 0 (typically 1) */
        unsigned int h_filter_p02c1:5;      /* Phase 02 coefficient 1 (typically -8) */
        unsigned int h_filter_p02c2:8;      /* Phase 02 coefficient 2 (typically 122) */
        unsigned int h_filter_p02c3:8;      /* Phase 02 coefficient 3 (typically 17) */
        unsigned int h_filter_p02c4:5;      /* Phase 02 coefficient 4 (typically -5) */
        unsigned int h_filter_p02c5:3;      /* Phase 02 coefficient 5 (typically 1) */
    };

    uint32_t reg32;
} winc_c_h_filter_p02_t;

#define WINC_C_H_FILTER_P03_RESET  0x00000000
typedef union winc_c_h_filter_p03_u {
    struct {
        unsigned int h_filter_p03c0:3;      /* Phase 03 coefficient 0 (typically 2) */
        unsigned int h_filter_p03c1:5;      /* Phase 03 coefficient 1 (typically -11) */
        unsigned int h_filter_p03c2:8;      /* Phase 03 coefficient 2 (typically 115) */
        unsigned int h_filter_p03c3:8;      /* Phase 03 coefficient 3 (typically 27) */
        unsigned int h_filter_p03c4:5;      /* Phase 03 coefficient 4 (typically -7) */
        unsigned int h_filter_p03c5:3;      /* Phase 03 coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_c_h_filter_p03_t;

#define WINC_C_H_FILTER_P04_RESET  0x00000000
typedef union winc_c_h_filter_p04_u {
    struct {
        unsigned int h_filter_p04c0:3;      /* Phase 04 coefficient 0 (typically 2) */
        unsigned int h_filter_p04c1:5;      /* Phase 04 coefficient 1 (typically -13) */
        unsigned int h_filter_p04c2:8;      /* Phase 04 coefficient 2 (typically 109) */
        unsigned int h_filter_p04c3:8;      /* Phase 04 coefficient 3 (typically 37) */
        unsigned int h_filter_p04c4:5;      /* Phase 04 coefficient 4 (typically -9) */
        unsigned int h_filter_p04c5:3;      /* Phase 04 coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_c_h_filter_p04_t;

#define WINC_C_H_FILTER_P05_RESET  0x00000000
typedef union winc_c_h_filter_p05_u {
    struct {
        unsigned int h_filter_p05c0:3;      /* Phase 05 coefficient 0 (typically 3) */
        unsigned int h_filter_p05c1:5;      /* Phase 05 coefficient 1 (typically -15) */
        unsigned int h_filter_p05c2:8;      /* Phase 05 coefficient 2 (typically 102) */
        unsigned int h_filter_p05c3:8;      /* Phase 05 coefficient 3 (typically 47) */
        unsigned int h_filter_p05c4:5;      /* Phase 05 coefficient 4 (typically -11) */
        unsigned int h_filter_p05c5:3;      /* Phase 05 coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_c_h_filter_p05_t;

#define WINC_C_H_FILTER_P06_RESET  0x00000000
typedef union winc_c_h_filter_p06_u {
    struct {
        unsigned int h_filter_p06c0:3;      /* Phase 06 coefficient 0 (typically 3) */
        unsigned int h_filter_p06c1:5;      /* Phase 06 coefficient 1 (typically -15) */
        unsigned int h_filter_p06c2:8;      /* Phase 06 coefficient 2 (typically 94) */
        unsigned int h_filter_p06c3:8;      /* Phase 06 coefficient 3 (typically 56) */
        unsigned int h_filter_p06c4:5;      /* Phase 06 coefficient 4 (typically -13) */
        unsigned int h_filter_p06c5:3;      /* Phase 06 coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_c_h_filter_p06_t;

#define WINC_C_H_FILTER_P07_RESET  0x00000000
typedef union winc_c_h_filter_p07_u {
    struct {
        unsigned int h_filter_p07c0:3;      /* Phase 07 coefficient 0 (typically 3) */
        unsigned int h_filter_p07c1:5;      /* Phase 07 coefficient 1 (typically -16) */
        unsigned int h_filter_p07c2:8;      /* Phase 07 coefficient 2 (typically 85) */
        unsigned int h_filter_p07c3:8;      /* Phase 07 coefficient 3 (typically 67) */
        unsigned int h_filter_p07c4:5;      /* Phase 07 coefficient 4 (typically -14) */
        unsigned int h_filter_p07c5:3;      /* Phase 07 coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_c_h_filter_p07_t;

#define WINC_C_H_FILTER_P08_RESET  0x00000000
typedef union winc_c_h_filter_p08_u {
    struct {
        unsigned int h_filter_p08c0:3;      /* Phase 08 coefficient 0 (typically 3) */
        unsigned int h_filter_p08c1:5;      /* Phase 08 coefficient 1 (typically -15) */
        unsigned int h_filter_p08c2:8;      /* Phase 08 coefficient 2 (typically 76) */
        unsigned int h_filter_p08c3:8;      /* Phase 08 coefficient 3 (typically 76) */
        unsigned int h_filter_p08c4:5;      /* Phase 08 coefficient 4 (typically -15) */
        unsigned int h_filter_p08c5:3;      /* Phase 08 coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_c_h_filter_p08_t;

#define WINC_C_H_FILTER_P09_RESET  0x00000000
typedef union winc_c_h_filter_p09_u {
    struct {
        unsigned int h_filter_p09c0:3;      /* Phase 09 coefficient 0 (typically 3) */
        unsigned int h_filter_p09c1:5;      /* Phase 09 coefficient 1 (typically -14) */
        unsigned int h_filter_p09c2:8;      /* Phase 09 coefficient 2 (typically 67) */
        unsigned int h_filter_p09c3:8;      /* Phase 09 coefficient 3 (typically 85) */
        unsigned int h_filter_p09c4:5;      /* Phase 09 coefficient 4 (typically -16) */
        unsigned int h_filter_p09c5:3;      /* Phase 09 coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_c_h_filter_p09_t;

#define WINC_C_H_FILTER_P0A_RESET  0x00000000
typedef union winc_c_h_filter_p0a_u {
    struct {
        unsigned int h_filter_p0ac0:3;      /* Phase 0A coefficient 0 (typically 3) */
        unsigned int h_filter_p0ac1:5;      /* Phase 0A coefficient 1 (typically -13) */
        unsigned int h_filter_p0ac2:8;      /* Phase 0A coefficient 2 (typically 56) */
        unsigned int h_filter_p0ac3:8;      /* Phase 0A coefficient 3 (typically 94) */
        unsigned int h_filter_p0ac4:5;      /* Phase 0A coefficient 4 (typically -15) */
        unsigned int h_filter_p0ac5:3;      /* Phase 0A coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_c_h_filter_p0a_t;

#define WINC_C_H_FILTER_P0B_RESET  0x00000000
typedef union winc_c_h_filter_p0b_u {
    struct {
        unsigned int h_filter_p0bc0:3;      /* Phase 0B coefficient 0 (typically 2) */
        unsigned int h_filter_p0bc1:5;      /* Phase 0B coefficient 1 (typically -11) */
        unsigned int h_filter_p0bc2:8;      /* Phase 0B coefficient 2 (typically 47) */
        unsigned int h_filter_p0bc3:8;      /* Phase 0B coefficient 3 (typically 102) */
        unsigned int h_filter_p0bc4:5;      /* Phase 0B coefficient 4 (typically -15) */
        unsigned int h_filter_p0bc5:3;      /* Phase 0B coefficient 5 (typically 3) */
    };

    uint32_t reg32;
} winc_c_h_filter_p0b_t;

#define WINC_C_H_FILTER_P0C_RESET  0x00000000
typedef union winc_c_h_filter_p0c_u {
    struct {
        unsigned int h_filter_p0cc0:3;      /* Phase 0C coefficient 0 (typically 2) */
        unsigned int h_filter_p0cc1:5;      /* Phase 0C coefficient 1 (typically -9) */
        unsigned int h_filter_p0cc2:8;      /* Phase 0C coefficient 2 (typically 37) */
        unsigned int h_filter_p0cc3:8;      /* Phase 0C coefficient 3 (typically 109) */
        unsigned int h_filter_p0cc4:5;      /* Phase 0C coefficient 4 (typically -13) */
        unsigned int h_filter_p0cc5:3;      /* Phase 0C coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_c_h_filter_p0c_t;

#define WINC_C_H_FILTER_P0D_RESET  0x00000000
typedef union winc_c_h_filter_p0d_u {
    struct {
        unsigned int h_filter_p0dc0:3;      /* Phase 0D coefficient 0 (typically 2) */
        unsigned int h_filter_p0dc1:5;      /* Phase 0D coefficient 1 (typically -7) */
        unsigned int h_filter_p0dc2:8;      /* Phase 0D coefficient 2 (typically 27) */
        unsigned int h_filter_p0dc3:8;      /* Phase 0D coefficient 3 (typically 115) */
        unsigned int h_filter_p0dc4:5;      /* Phase 0D coefficient 4 (typically -11) */
        unsigned int h_filter_p0dc5:3;      /* Phase 0D coefficient 5 (typically 2) */
    };

    uint32_t reg32;
} winc_c_h_filter_p0d_t;

#define WINC_C_H_FILTER_P0E_RESET  0x00000000
typedef union winc_c_h_filter_p0e_u {
    struct {
        unsigned int h_filter_p0ec0:3;      /* Phase 0E coefficient 0 (typically 1) */
        unsigned int h_filter_p0ec1:5;      /* Phase 0E coefficient 1 (typically -5) */
        unsigned int h_filter_p0ec2:8;      /* Phase 0E coefficient 2 (typically 17) */
        unsigned int h_filter_p0ec3:8;      /* Phase 0E coefficient 3 (typically 122) */
        unsigned int h_filter_p0ec4:5;      /* Phase 0E coefficient 4 (typically -8) */
        unsigned int h_filter_p0ec5:3;      /* Phase 0E coefficient 5 (typically 1) */
    };

    uint32_t reg32;
} winc_c_h_filter_p0e_t;

#define WINC_C_H_FILTER_P0F_RESET  0x00000000
typedef union winc_c_h_filter_p0f_u {
    struct {
        unsigned int h_filter_p0fc0:3;      /* Phase 0F coefficient 0 (typically 1) */
        unsigned int h_filter_p0fc1:5;      /* Phase 0F coefficient 1 (typically -2) */
        unsigned int h_filter_p0fc2:8;      /* Phase 0F coefficient 2 (typically 8) */
        unsigned int h_filter_p0fc3:8;      /* Phase 0F coefficient 3 (typically 124) */
        unsigned int h_filter_p0fc4:5;      /* Phase 0F coefficient 4 (typically -4) */
        unsigned int h_filter_p0fc5:3;      /* Phase 0F coefficient 5 (typically 1) */
    };

    uint32_t reg32;
} winc_c_h_filter_p0f_t;

#define WINC_C_CSC_YOF_RESET  0x00000000
typedef union winc_c_csc_yof_u {
    struct {
        unsigned int csc_yof:8;             /* Y Offset in s.7.0 format */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} winc_c_csc_yof_t;

#define WINC_C_CSC_KYRGB_RESET  0x00000000
typedef union winc_c_csc_kyrgb_u {
    struct {
        unsigned int csc_kyrgb:10;          /* Y Gain for R, G, B colors in 2.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} winc_c_csc_kyrgb_t;

#define WINC_C_CSC_KUR_RESET  0x00000000
typedef union winc_c_csc_kur_u {
    struct {
        unsigned int csc_kur:11;            /* U coefficients for R in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} winc_c_csc_kur_t;

#define WINC_C_CSC_KVR_RESET  0x00000000
typedef union winc_c_csc_kvr_u {
    struct {
        unsigned int csc_kvr:11;            /* V coefficients for R in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} winc_c_csc_kvr_t;

#define WINC_C_CSC_KUG_RESET  0x00000000
typedef union winc_c_csc_kug_u {
    struct {
        unsigned int csc_kug:10;            /* U coefficients for G in s.1.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} winc_c_csc_kug_t;

#define WINC_C_CSC_KVG_RESET  0x00000000
typedef union winc_c_csc_kvg_u {
    struct {
        unsigned int csc_kvg:10;            /* V coefficients for G in s.1.8 format */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} winc_c_csc_kvg_t;

#define WINC_C_CSC_KUB_RESET  0x00000000
typedef union winc_c_csc_kub_u {
    struct {
        unsigned int csc_kub:11;            /* U coefficients for B in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} winc_c_csc_kub_t;

#define WINC_C_CSC_KVB_RESET  0x00000000
typedef union winc_c_csc_kvb_u {
    struct {
        unsigned int csc_kvb:11;            /* V coefficients for B in s.2.8 format */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} winc_c_csc_kvb_t;

#define WIN_C_WIN_OPTIONS_RESET  0x00000000
typedef union win_c_win_options_u {
    struct {
        unsigned int h_direction:1;         /* Window C Horizontal (X) drawing Direction  0 = INCREMENT 1 = DECREMENT */
        unsigned int undefined_bit_1:1;
        unsigned int v_direction:1;         /* Window C Vertical (Y) drawing Direction  0 = INCREMENT; 1 = DECREMENT */
        unsigned int undefined_bits_3_5:3;
        unsigned int color_expand:1;        /* Window C 12/15/16/18-to-24 bpp color expansion This bit should be enabled only for 12-bpp B4G4R4A4, 15-bpp B5G5R5A, 16-bpp B5G6R5, 18-bpp B6G6R6 color modes. If enabled the color conversion is performed prior to horizontal scaling.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int h_filter_enable:1;     /* Window C H Filter Enable This controls H scaling filter and is effective only for non-palletized color modes.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_9_15:7;
        unsigned int cp_enable:1;           /* Window C Color Palette Enable This controls the color palette and should be enabled for palletized color modes. For non-palletized color modes, the color palette can be enabled for gamma correction.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int csc_enable:1;          /* Window C Color Space Conversion Enable This controls the color space conversion and should be enabled for YCbCr/YUV color modes for conversion to B8G8R8 and for hue and saturation control. This can also be used for gain control for RGB color modes.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int dv_enable:1;           /* Window C Digital Vibrance Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int yuv_range_expand:1;    /* Window C Enable range expansion in the cases where RANGEREDFRM is 1 from mpd. Formula: Y = clip(( Y-128)*2 + 128); Cb = clip((Cb-128)*2 + 128); Cr = clip((Cr-128)*2 + 128); where clip() function clips between 0 and 255. 0= disable 1= enable 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_23_29:7;
        unsigned int win_enable:1;          /* Window C Window enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} win_c_win_options_t;

#define WIN_C_BYTE_SWAP_RESET  0x00000000
typedef union win_c_byte_swap_u {
    struct {
        unsigned int byte_swap:2;           /* Window C Byte Swap This controls byte swap of frame data read from memory prior to any data processing in the display module. 00= no byte swap (3 2 1 0) 01= byte swap for each 2-byte word (2 3 0 1) 10= byte swap for each 4-byte word (0 1 2 3) 11= word swap for each 4-byte word (1 0 3 2) 0 = NOSWAP 1 = SWAP2 2 = SWAP4 3 = SWAP4HW */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} win_c_byte_swap_t;

#define WIN_C_BUFFER_CONTROL_RESET  0x00000000
typedef union win_c_buffer_control_u {
    struct {
        unsigned int buffer_control:3;      /* Window C Buffer Control 0= Host (software) controlled 1= Video Input controlled 2= Encoder Pre-Processor controlled 3= MPEG Encoder controlled 4= StretchBLT or 2D other= reserved If window buffer selection is not controlled by host (software) then buffer start indexes are sent by the respective module specified by this parameter, and in this case, the buffer start address registers are used to specify frame stride and buffer offset for the calculated start address. 0 = HOST 1 = VI 2 = EPP 4 = SB2D 3 = MPEGE */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} win_c_buffer_control_t;

#define WIN_C_COLOR_DEPTH_RESET  0x00000000
typedef union win_c_color_depth_u {
    struct {
        unsigned int color_depth:5;         /* Window C Color Depth Supported color depths are: P8 = 8-bpp (palletized) B4G4R4A4 = 12-bpp B4G4R4 B5G5R5A = 15-bpp B5G5R5 AB5G5R5 = 15-bpp B5G5R5 B5G6R5 = 16-bpp B5G6R5 B8G8R8A8 = 32-bpp B8G8R8A8 R8G8B8A8 = 32-bpp R8G8B8A8 B6x2G6x2R6x2A8 = 32-bpp B6G6R6A8 R6x2G6x2B6x2A8 = 32-bpp R6G6B6A8 YCbCr422 = 16-bpp YCbCr422 packed YUV422 = 16-bpp YUV422 YCbCr420P = 16-bpp YCbCr420 planar YUV420P = 16-bpp YUV420 planar YCbCr422P = 16-bpp YCbCr422 planar YUV422P = 16-bpp YUV422 planar YCbCr422R = 16-bpp YCbCr422 rotated planar YUV422R = 16-bpp YUV422 rotated planar YCbCr422RA= 16-bpp YCbCr422 rotated planar with chroma averaging YUV422RA = 16-bpp YUV422 rotated planar with chroma averaging 0 = P1 1 = P2 2 = P4 3 = P8 4 = B4G4R4A4 5 = B5G5R5A 6 = B5G6R5 7 = AB5G5R5 12 = B8G8R8A8 13 = R8G8B8A8 14 = B6x2G6x2R6x2A8 15 = R6x2G6x2B6x2A8 16 = YCbCr422 17 = YUV422 18 = YCbCr420P 19 = YUV420P 20 = YCbCr422P 21 = YUV422P 22 = YCbCr422R 23 = YUV422R 24 = YCbCr422RA 25 = YUV422RA */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} win_c_color_depth_t;

#define WIN_C_POSITION_RESET  0x00000000
typedef union win_c_position_u {
    struct {
        unsigned int h_position:13;         /* Window C H Position This is specified with respect to the left edge of active display area */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_position:13;         /* Window C V Position This is specified with respect to the top edge of active display area */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} win_c_position_t;

#define WIN_C_SIZE_RESET  0x00000000
typedef union win_c_size_u {
    struct {
        unsigned int h_size:13;             /* Window C H Size (pixels) This is the horizontal size after scaling */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_size:13;             /* Window C V Size (lines) This is the vertical size after scaling */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} win_c_size_t;

#define WIN_C_PRESCALED_SIZE_RESET  0x00000000
typedef union win_c_prescaled_size_u {
    struct {
        unsigned int h_prescaled_size:15;   /* Window C H Pre-scaled Size (bytes) In 420P and 422P formats, it must be even */
        unsigned int undefined_bit_15:1;
        unsigned int v_prescaled_size:13;   /* Window C V Pre-scaled Size (lines) In 420P/422R/422RA formats, it must be even */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} win_c_prescaled_size_t;

#define WIN_C_H_INITIAL_DDA_RESET  0x00000000
typedef union win_c_h_initial_dda_u {
    struct {
        unsigned int h_initial_dda:16;      /* Window C H Initial DDA (4.12) This is typically programmed to 0.0 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} win_c_h_initial_dda_t;

#define WIN_C_V_INITIAL_DDA_RESET  0x00000000
typedef union win_c_v_initial_dda_u {
    struct {
        unsigned int v_initial_dda:16;      /* Window C V Initial DDA (4.12) This is typically programmed to 0.0 for both non-interlaced and interlaced sources */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} win_c_v_initial_dda_t;

#define WIN_C_DDA_INCREMENT_RESET  0x00000000
typedef union win_c_dda_increment_u {
    struct {
        unsigned int h_dda_increment:16;    /* Window C Horizontal DDA Increment (4.12) This should be set to 1.0 if there is no scaling. The maximum value for downscaling depends on the number of bytes per pixel. For 4-byte/pixel modes (32-bpp) the maximum value is 4.0 and for all other modes the maximum value is 8.0 */
        unsigned int v_dda_increment:16;    /* Window C Vertical DDA Increment (4.12) This should be set to 1.0 if there is no scaling. Maximum value is 15.0 regardless of the number of bytes per pixel */
    };

    uint32_t reg32;
} win_c_dda_increment_t;

#define WIN_C_LINE_STRIDE_RESET  0x00000000
typedef union win_c_line_stride_u {
    struct {
        unsigned int line_stride:16;        /* Window C Line Stride This is stride (in bytes) for all non-planar data formats. If the memory surface is tiled, the stride needs to be a multiple of 16. If H_DIRECTION of window C is set to DECREMENT, the stride also needs to be a multiple of 16. For planar YUV or YCbCr data formats, this is stride (in bytes) for the luma plane with the restriction that it must be multiples of 8 (16 if tiled or in horizontal flipping) For tiled surface this value may affect starting address of a window. Refer to the comment of START_ADDR for detail */
        unsigned int uv_line_stride:16;     /* Window C Line Stride for Chroma This is stride (in bytes) for planar YUV or YCbCr data formats for the chroma plane, with the restriction that it must be programmed to be multiples of 4 (16 if tiled or in horizontal flipping) This is not used (ignored) for other non-planar data formats */
    };

    uint32_t reg32;
} win_c_line_stride_t;

#define WIN_C_BUF_STRIDE_RESET  0x00000000
typedef union win_c_buf_stride_u {
    struct {
        unsigned int buf_stride:32;         /* Window C Buffer stride Buffer stride is used to calculate the buffer addresses when the window is triggered by non-host modules. Refer to the comment of START_ADDR for programming guide. For YUV planar pixel format, this specifies buffer stride for the Y plane. The value is in bytes */
    };

    uint32_t reg32;
} win_c_buf_stride_t;

#define WIN_C_UV_BUF_STRIDE_RESET  0x00000000
typedef union win_c_uv_buf_stride_u {
    struct {
        unsigned int uv_buf_stride:32;      /* Window C This value is in bytes. For YUV planar pixel format, this specifies buffer stride for the U/V plane */
    };

    uint32_t reg32;
} win_c_uv_buf_stride_t;

#define WIN_C_BUFFER_ADDR_MODE_RESET  0x00000000
typedef union win_c_buffer_addr_mode_u {
    struct {
        unsigned int tile_mode:1;           /* Window C Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the Y plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_1_15:15;
        unsigned int uv_tile_mode:1;        /* Window C Memory surface tiling mode For YUV planar pixel format, this specifies tiling mode for the U/V plane. 0 = LINEAR 1 = TILED */
        unsigned int undefined_bits_17_31:15;
    };

    uint32_t reg32;
} win_c_buffer_addr_mode_t;

#define WIN_C_DV_CONTROL_RESET  0x00000000
typedef union win_c_dv_control_u {
    struct {
        unsigned int dv_control_r:3;        /* Digital Vibrance control for R */
        unsigned int undefined_bits_3_7:5;
        unsigned int dv_control_g:3;        /* Digital Vibrance control for G */
        unsigned int undefined_bits_11_15:5;
        unsigned int dv_control_b:3;        /* Digital Vibrance control for B */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} win_c_dv_control_t;

#define WIN_C_BLEND_NOKEY_RESET  0x00000000
typedef union win_c_blend_nokey_u {
    struct {
        unsigned int blend_control_nokey:1; /* Window blend control for color key not match areas. 0 = Fix weight using window blend weight 0 for color key not matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_1_7:7;
        unsigned int blend_weight0_nokey:8; /* Window blend weight 0 for color key not match areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_nokey:8; /* Window blend weight 1 for color key not match areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_c_blend_nokey_t;

#define WIN_C_BLEND_1WIN_RESET  0x00000000
typedef union win_c_blend_1win_u {
    struct {
        unsigned int ckey_enable_1win:2;    /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_1win:1;  /* Window blend control in area where it does not overlap with other windows and either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT */
        unsigned int undefined_bits_3_7:5;
        unsigned int blend_weight0_1win:8;  /* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_1win:8;  /* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_c_blend_1win_t;

#define WIN_C_BLEND_2WIN_A_RESET  0x00000000
typedef union win_c_blend_2win_a_u {
    struct {
        unsigned int ckey_enable_2win_a:2;  /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_2win_a:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int blend_weight0_2win_a:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_2win_a:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_c_blend_2win_a_t;

#define WIN_C_BLEND_2WIN_B_RESET  0x00000000
typedef union win_c_blend_2win_b_u {
    struct {
        unsigned int ckey_enable_2win_b:2;  /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY; 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_2win_b:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int blend_weight0_2win_b:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_2win_b:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_c_blend_2win_b_t;

#define WIN_C_BLEND_3WIN_AB_RESET  0x00000000
typedef union win_c_blend_3win_ab_u {
    struct {
        unsigned int ckey_enable_3win_ab:2; /* Window color key enable 0 = Color Key 0 and 1 Disable 1 = Color Key 0 Enable 2 = Color Key 1 Enable 3 = Color Key 0 and 1 Enable 0 = NOKEY 1 = CKEY0 2 = CKEY1 3 = CKEY01 */
        unsigned int blend_control_3win_ab:2;/* Window blend control in area where either color key disabled or color key enabled with key matched. 0 = Fix weight using the window blend weight 0 if color key disabled or color key 0 enabled with key matched, or using the window blend weight 1 if color key 1 enabled with key matched. 1 = Alpha weight using the alpha value. This is only valid if the window color format includes an alpha value. For 1-bit alpha value, if the alpha is 0 window blend weight 0 is used and if alpha is 1, window blend weight 1 is used. 2 = Dependent weight, in this case, the window blend weight is 1 - the weights of the other window that overlaps with this window. Only 1 of the overlapping windows may have this setting. 0 = FIX_WEIGHT 1 = ALPHA_WEIGHT 2 = DEPENDENT_WEIGHT */
        unsigned int undefined_bits_4_7:4;
        unsigned int blend_weight0_3win_ab:8;/* Window blend weight 0 for color key disabled or color key enabled with key matched areas. For alpha weight, this is used for 1-bit alpha with value of 0 */
        unsigned int blend_weight1_3win_ab:8;/* Window blend weight 1 for color key disabled or color key enabled with key matched areas. This is used only for alpha weight with 1-bit alpha and alpha value of 1 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} win_c_blend_3win_ab_t;

#define WIN_C_HP_FETCH_CONTROL_RESET  0x00000000
typedef union win_c_hp_fetch_control_u {
    struct {
        unsigned int cycles_per_word:16;    /* Window C clock cycles per memory fetch word. The value of this field is essentially a measure of the data consumption rate for window C. It is computed as follows: C_CYCLES_PER_WORD = C_DDA_INCREMENT.C_H_DDA_INCREMENT / (bytes per pixel) Note that the format for this value is a fixed-point fractional value with 8 bits of integer precision and 8 bits of fractional precision. In other words, it is an '8.8' number. For example, if there is no scaling of the input image, the DDA increment will be 4096. With 32-bit RGBA pixels there will be 4 bytes per pixel, so CYCLES_PER_WORD will be ... 4096 / 4 = 1024, or 4.0 expressed in the 8.8 format. Any scaling performed on the pixels will change the rate at which pixels are consumed. Scaling up will increase the value of DDA increment and will therefore increase the number of cycles between memory fetches. Conversely, scaling down will decrease the value of DDA increment and memory fetches will occur more frequently */
        unsigned int words_per_line:15;     /* Window C memory fetch words per scan line. This value is in memory fetch words: Multiples of 16 bytes for Tegra 2 Processor Series devices. It is computed as follows: C_WORDS_PER_LINE = (C_SIZE.C_H_SIZE * (bytes per pixel) + 15) >> 4 bytes per pixel is determined by the pixel format */
        unsigned int fetch_info_enable:1;   /* Enables the sending of the Window C fetch information. For compatibility with earlier devices, this defaults to DISABLE. 0 = DISABLE : This bit should be enabled only for 12-bpp  1 = ENABLE */
    };

    uint32_t reg32;
} win_c_hp_fetch_control_t;

#define WINBUF_C_START_ADDR_RESET  0x00000000
typedef union winbuf_c_start_addr_u {
    struct {
        unsigned int start_addr:32;         /* Window C Start Address This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies start address for the Y plane */
    };

    uint32_t reg32;
} winbuf_c_start_addr_t;

#define WINBUF_C_START_ADDR_NS_RESET  0x00000000
typedef union winbuf_c_start_addr_ns_u {
    struct {
        unsigned int start_addr_ns:32;      /* Window C Shadowed Start Address This is ARM set shadow of Start Address */
    };

    uint32_t reg32;
} winbuf_c_start_addr_ns_t;

#define WINBUF_C_START_ADDR_U_RESET  0x00000000
typedef union winbuf_c_start_addr_u_u {
    struct {
        unsigned int start_addr_u:32;       /* Window C Start Address for U plane This is a byte address */
    };

    uint32_t reg32;
} winbuf_c_start_addr_u_t;

#define WINBUF_C_START_ADDR_U_NS_RESET  0x00000000
typedef union winbuf_c_start_addr_u_ns_u {
    struct {
        unsigned int start_addr_u_ns:32;    /* Window C Shadowed Start Address for U plane This is ARM set shadow register of U start address */
    };

    uint32_t reg32;
} winbuf_c_start_addr_u_ns_t;

#define WINBUF_C_START_ADDR_V_RESET  0x00000000
typedef union winbuf_c_start_addr_v_u {
    struct {
        unsigned int start_addr_v:32;       /* Window C Start Address for V plane This is a byte address */
    };

    uint32_t reg32;
} winbuf_c_start_addr_v_t;

#define WINBUF_C_START_ADDR_V_NS_RESET  0x00000000
typedef union winbuf_c_start_addr_v_ns_u {
    struct {
        unsigned int start_addr_v_ns:32;    /* Window C Shadowed Start Address for V plane This is ARM set shadow register of U start address */
    };

    uint32_t reg32;
} winbuf_c_start_addr_v_ns_t;

#define WINBUF_C_ADDR_H_OFFSET_RESET  0x00000000
typedef union winbuf_c_addr_h_offset_u {
    struct {
        unsigned int addr_h_offset:32;      /* Window C Horizontal address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies horizontal offset of Y plane. The horizontal offsets of U/V plane is derived by HW */
    };

    uint32_t reg32;
} winbuf_c_addr_h_offset_t;

#define WINBUF_C_ADDR_H_OFFSET_NS_RESET  0x00000000
typedef union winbuf_c_addr_h_offset_ns_u {
    struct {
        unsigned int addr_h_offset_ns:32;   /* Window C Shadowed Horizontal address offset This is ARM set shadow of ADDR_H_OFFSET */
    };

    uint32_t reg32;
} winbuf_c_addr_h_offset_ns_t;

#define WINBUF_C_ADDR_V_OFFSET_RESET  0x00000000
typedef union winbuf_c_addr_v_offset_u {
    struct {
        unsigned int addr_v_offset:32;      /* Window C Vertical address offset This is a byte address. The LSB is not used for 16-bpp non-planar pixel format and the last 2 LSB are not used for 32-bpp non-planar pixel format. For YUV planar pixel format, this specifies vertical offset of Y plane. The vertical offsets of U/V plane is derived by HW */
    };

    uint32_t reg32;
} winbuf_c_addr_v_offset_t;

#define WINBUF_C_ADDR_V_OFFSET_NS_RESET  0x00000000
typedef union winbuf_c_addr_v_offset_ns_u {
    struct {
        unsigned int addr_v_offset_ns:32;   /* Window C Shadowed Vertical address offset This is ARM set shadow of ADDR_V_OFFSET */
    };

    uint32_t reg32;
} winbuf_c_addr_v_offset_ns_t;

#define WINBUF_C_UFLOW_STATUS_RESET  0x00000000
typedef union winbuf_c_uflow_status_u {
    struct {
        unsigned int uflow_count:24;        /* Underflow count. This field indicates the number of contiguous groups of output pixels for which there was no data in the FIFO. For example, if the valid from the FIFO is low for 10 consecutive cycles and then goes high, the counter will increment by one. Reset to zero on write */
        unsigned int undefined_bits_24_29:6;
        unsigned int count_oflow:1;         /* Flag bit that indicates that the underflow event counter has overflowed. There were too many events. If COUNT_OFLOW is set, UFLOW_COUNT is meaningless. Cleared on write */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} winbuf_c_uflow_status_t;

#define DISP_SD_CONTROL_OFFSET 0x4C2
#define DISP_SD_CONTROL_RESET  0x00000000
typedef union disp_sd_control_u {
    struct {
        unsigned int sd_enable:1;           /* Enables the Smart Dimmer Function */
        unsigned int use_vid_luma:1;        /* Use Video Luminance control of luminance: Luminance = MAX(R, G, B) ENABLE = use "video" luminance, which is determined by the coefficients in the SD_CSC_COEFFS register See the SD_CSC_COEFFS register for details. */
        unsigned int bin_width:2;           /* Width of the Histogram bins, in quantisation levels. EIGHT = 8 levels per bin. Bins span range from   0 to 255 */
        unsigned int aggressiveness:3;      /* The "aggressiveness" level of the Smart Dimmer algorithm. Higher aggressiveness levels result in higher power savings at the potential expense of image quality. The number programmed determines how many highlight pixels will be allowed to exceed the maximum representable brightness value and be clipped to that value. It also determines the maximum allowed enhancement value (k) applied to the pixel brightness. AGGRESSIVENESS Description         % pixels  Max. k      value                          crushed  value        0       Essentially off          0%    1.00        1       Highest quality       <  5%    1.10        2       Higher quality        < 10%    1.15        3       Balanced              < 15%    1.20        4       Higher battery life   < 20%    1.25        5       Highest battery life  < 25%    1.50 */
        unsigned int hw_update_dly:2;       /* Determines the delay - in video frames - of the update of the hardware enhancement value that is applied to the pixels. This is useful for allowing the software some time to update the backlight control, when the control must be sent via side-band control packets or by some other means of control that incurs a sizeable delay. Being able to delay the hardware update ensures that the modification of the pixels occurs as nearly simultaneously with the update of the backlight as possible. Value Description   0   No delay - pixels modified immediately   1   New enhancemant value delayed by 1 frame.   2   New enhancement value delayed by 2 frames.   3   New enhancement value delayed by 3 frames. */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} disp_sd_control_t;

#define DISP_SD_CSC_COEFF_OFFSET 0x4C3
#define DISP_SD_CSC_COEFF_RESET  0x00000000
typedef union disp_sd_csc_coeff_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int r_coeff:4;             /* green and blue color components into a luminance value. */
        unsigned int undefined_bits_8_11:4;
        unsigned int g_coeff:4;             /* The conversion is performed according to the following equation: */
        unsigned int undefined_bits_16_19:4;
        unsigned int b_coeff:4;             /* Luminance = (R * R_COEFF + G * G_COEFF + B * B_COEFF) >> 4 It is suggested that the values of the coefficients be programmed as shown below, though user-defined color spaces are also accommodated. Color Space  R_COEFF G_COEFF B_COEFF ITU-R Bt601      5       9       2 ITU-R Bt709      3      12       1 The coefficients do not have to be particularly accurate, hence their low precision and the coefficients used are open to experimentation to obtain the best results. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_csc_coeff_t;

#define DISP_SD_LUT_OFFSET 0x4C4
#define DISP_SD_LUT_RESET  0x00000000
typedef union disp_sd_lut_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_lut_t;

#define DISP_SD_LUT_1_OFFSET 0x4C5
#define DISP_SD_LUT_1_RESET  0x00000000
typedef union disp_sd_lut_1_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_lut_1_t;

#define DISP_SD_LUT_2_OFFSET 0x4C6
#define DISP_SD_LUT_2_RESET  0x00000000
typedef union disp_sd_lut_2_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_lut_2_t;

#define DISP_SD_LUT_3_OFFSET 0x4C7
#define DISP_SD_LUT_3_RESET  0x00000000
typedef union disp_sd_lut_3_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_lut_3_t;

#define DISP_SD_LUT_4_OFFSET 0x4C8
#define DISP_SD_LUT_4_RESET  0x00000000
typedef union disp_sd_lut_4_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_lut_4_t;

#define DISP_SD_LUT_5_OFFSET 0x4C9
#define DISP_SD_LUT_5_RESET  0x00000000
typedef union disp_sd_lut_5_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_lut_5_t;

#define DISP_SD_LUT_6_OFFSET 0x4CA
#define DISP_SD_LUT_6_RESET  0x00000000
typedef union disp_sd_lut_6_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_lut_6_t;

#define DISP_SD_LUT_7_OFFSET 0x4CB
#define DISP_SD_LUT_7_RESET  0x00000000
typedef union disp_sd_lut_7_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_lut_7_t;

#define DISP_SD_LUT_8_OFFSET 0x4CC
#define DISP_SD_LUT_8_RESET  0x00000000
typedef union disp_sd_lut_8_u {
    struct {
        unsigned int r_lut:8;               /* Each LUT entry contains the value of k for each of the three color */
        unsigned int g_lut:8;               /* components. Since the value of k for the color components must be */
        unsigned int b_lut:8;               /* the reciprocal of the hardware-computed value of k, and the HW value is guaranteed to be less than or equal to 1, the values in the LUT represent the fractional part of k, with an implied 1 to the left of the decimal place. For example, if the programmed value of R_LUT was 64 ( 01000000 in binary ), then the actual value of k generted would be 1.01000000 in binary or 1.25 in decimal. To program a default, linear response into the LUT, use the following code as a guide: for (i = 0; i < 9; i++) {   t = (4096 / (8 + i)) - 256;   if (t > 255) t = 255;   R_LUT[i] = t;   G_LUT[i] = t;   B_LUT[i] = t;   } For other non-linear response curves (for example, to take display gamma into consideration), this code will have to be modified. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_lut_8_t;

#define DISP_SD_FLICKER_CONTROL_OFFSET 0x4CD
#define DISP_SD_FLICKER_CONTROL_RESET  0x00000000
typedef union disp_sd_flicker_control_u {
    struct {
        unsigned int time_limit:8;          /* Length of time - in frames - that the enhancement value must deviate from the current value by more than THRESHOLD, before the enhancement value changes. */
        unsigned int threshold:8;           /* The amount by which the currently calcualted enhancement value must deviate from the currently active enhancement value for it to increment the TIME_LIMIT counter. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} disp_sd_flicker_control_t;

#define DISP_SD_PIXEL_COUNT_OFFSET 0x4CE
#define DISP_SD_PIXEL_COUNT_RESET  0x00000000
#define DISP_SD_PIXEL_COUNT_WRMASK 0xFFFF0000
typedef union disp_sd_pixel_count_u {
    struct {
        unsigned int num_pixels:16;         /* in the preceeding output frame. Expressed as a quantity of 256 pixels. In other words, a 640 x 480 image has 307200 pixels. The value in this register would be 307200 / 256 = 1200 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} disp_sd_pixel_count_t;

#define DISP_SD_HISTOGRAM_OFFSET 0x4CF
#define DISP_SD_HISTOGRAM_RESET  0x00000000
typedef union disp_sd_histogram_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    uint32_t reg32;
} disp_sd_histogram_t;

#define DISP_SD_HISTOGRAM_1_OFFSET 0x4D0
#define DISP_SD_HISTOGRAM_1_RESET  0x00000000
typedef union disp_sd_histogram_1_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    uint32_t reg32;
} disp_sd_histogram_1_t;

#define DISP_SD_HISTOGRAM_2_OFFSET 0x4D1
#define DISP_SD_HISTOGRAM_2_RESET  0x00000000
typedef union disp_sd_histogram_2_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    uint32_t reg32;
} disp_sd_histogram_2_t;

#define DISP_SD_HISTOGRAM_3_OFFSET 0x4D2
#define DISP_SD_HISTOGRAM_3_RESET  0x00000000
typedef union disp_sd_histogram_3_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    uint32_t reg32;
} disp_sd_histogram_3_t;

#define DISP_SD_HISTOGRAM_4_OFFSET 0x4D3
#define DISP_SD_HISTOGRAM_4_RESET  0x00000000
typedef union disp_sd_histogram_4_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    uint32_t reg32;
} disp_sd_histogram_4_t;

#define DISP_SD_HISTOGRAM_5_OFFSET 0x4D4
#define DISP_SD_HISTOGRAM_5_RESET  0x00000000
typedef union disp_sd_histogram_5_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    uint32_t reg32;
} disp_sd_histogram_5_t;

#define DISP_SD_HISTOGRAM_6_OFFSET 0x4D5
#define DISP_SD_HISTOGRAM_6_RESET  0x00000000
typedef union disp_sd_histogram_6_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    uint32_t reg32;
} disp_sd_histogram_6_t;

#define DISP_SD_HISTOGRAM_7_OFFSET 0x4D6
#define DISP_SD_HISTOGRAM_7_RESET  0x00000000
typedef union disp_sd_histogram_7_u {
    struct {
        unsigned int bin_0:8;               /* Each register contains 4 histogram bins, for a total of 8 x 4 = 32 bins. */
        unsigned int bin_1:8;               /* Each bin has been approximtely scaled to the number of pixels in the image */
        unsigned int bin_2:8;               /* so that a single quantisation step in a bin represents a fraction of */
        unsigned int bin_3:8;               /* between 1/256 and 1/128 of the total number of pixels in the image. */
    };

    uint32_t reg32;
} disp_sd_histogram_7_t;

#define DISP_SD_BL_PARAMETERS_OFFSET 0x4D7
#define DISP_SD_BL_PARAMETERS_RESET  0x00000400
typedef union disp_sd_bl_parameters_u {
    struct {
        unsigned int time_constant:11;      /* The time constant for the response curve. This value represents the fraction by which the value of enhancement value approaches the target value each frame. Example values are shown below:    0 : The value will never reach the target (infinite TC)  512 : The next value will be half-way betwen the current value and the        target value. 1024 : The next value will be 100% of the target value. In other words -        an instantaneous response. */
        unsigned int undefined_bits_11_15:5;
        unsigned int step:8;                /* Determines the instantaneous portion of the target value of enhancement that is applied.   0 =   0% : response is entirely exponential and determined by TIME_CONSTANT 128 =  50% : response will instantly step up by 50% and will then be exponential. 255 = 100% : response is entirely instantaneous. TIME_CONSTANT has no effect. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_sd_bl_parameters_t;

#define DISP_SD_BL_TF_OFFSET 0x4D8
#define DISP_SD_BL_TF_RESET  0x00000000
typedef union disp_sd_bl_tf_u {
    struct {
        unsigned int point_0:8;             /* Each register contains 4 points on the Transfer Function curve that defines */
        unsigned int point_1:8;             /* how the backlight output changes with respect to the control input. Each point */
        unsigned int point_2:8;             /* defines a value at the vertex of a 16 segment line. The 17th point is defined */
        unsigned int point_3:8;             /* to be the maximum value (it is assumed 100% control == 100% light output). */
    };

    uint32_t reg32;
} disp_sd_bl_tf_t;

#define DISP_SD_BL_TF_1_OFFSET 0x4D9
#define DISP_SD_BL_TF_1_RESET  0x00000000
typedef union disp_sd_bl_tf_1_u {
    struct {
        unsigned int point_0:8;             /* Each register contains 4 points on the Transfer Function curve that defines */
        unsigned int point_1:8;             /* how the backlight output changes with respect to the control input. Each point */
        unsigned int point_2:8;             /* defines a value at the vertex of a 16 segment line. The 17th point is defined */
        unsigned int point_3:8;             /* to be the maximum value (it is assumed 100% control == 100% light output). */
    };

    uint32_t reg32;
} disp_sd_bl_tf_1_t;

#define DISP_SD_BL_TF_2_OFFSET 0x4DA
#define DISP_SD_BL_TF_2_RESET  0x00000000
typedef union disp_sd_bl_tf_2_u {
    struct {
        unsigned int point_0:8;             /* Each register contains 4 points on the Transfer Function curve that defines */
        unsigned int point_1:8;             /* how the backlight output changes with respect to the control input. Each point */
        unsigned int point_2:8;             /* defines a value at the vertex of a 16 segment line. The 17th point is defined */
        unsigned int point_3:8;             /* to be the maximum value (it is assumed 100% control == 100% light output). */
    };

    uint32_t reg32;
} disp_sd_bl_tf_2_t;

#define DISP_SD_BL_TF_3_OFFSET 0x4DB
#define DISP_SD_BL_TF_3_RESET  0x00000000
typedef union disp_sd_bl_tf_3_u {
    struct {
        unsigned int point_0:8;             /* Each register contains 4 points on the Transfer Function curve that defines */
        unsigned int point_1:8;             /* how the backlight output changes with respect to the control input. Each point */
        unsigned int point_2:8;             /* defines a value at the vertex of a 16 segment line. The 17th point is defined */
        unsigned int point_3:8;             /* to be the maximum value (it is assumed 100% control == 100% light output). */
    };

    uint32_t reg32;
} disp_sd_bl_tf_3_t;

#define DISP_SD_BL_CONTROL_OFFSET 0x4DC
#define DISP_SD_BL_CONTROL_RESET  0x00000000
#define DISP_SD_BL_CONTROL_WRMASK 0xFFFF00FF
typedef union disp_sd_bl_control_u {
    struct {
        unsigned int bl_mode:2;             /* Control Mode:            and adjust the backlight brightness itself. PWM_AUTO : Hardware willadjust the backlight PWM control signal directly using            the value in BRIGHTNESS. * OTHER VALUES ARE RESERVED FOR FUTURE USE * */
        unsigned int undefined_bits_2_7:6;
        unsigned int brightness:8;          /* Backlight brightness modification value. This value is determined by the hardware according to all the other control registers and the image content. The amount by which the backlight should be modified is given as a fraction with 0 representing that the backlight should be off and 255 representing no change in the backlight intensity. Other values vary linearly between these two extremes. Put another way: New BL control = (Old BL control * BRIGHTNESS) / 255 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} disp_sd_bl_control_t;

#define WINC_COLOR_PALETTE_1_OFFSET 0x501
#define WINC_B_COLOR_PALETTE_1_RESET  0x00000000
typedef union winc_b_color_palette_1_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_1_t;

#define WINC_COLOR_PALETTE_2_OFFSET 0x502
#define WINC_B_COLOR_PALETTE_2_RESET  0x00000000
typedef union winc_b_color_palette_2_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_2_t;

#define WINC_COLOR_PALETTE_3_OFFSET 0x503
#define WINC_B_COLOR_PALETTE_3_RESET  0x00000000
typedef union winc_b_color_palette_3_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_3_t;

#define WINC_COLOR_PALETTE_4_OFFSET 0x504
#define WINC_B_COLOR_PALETTE_4_RESET  0x00000000
typedef union winc_b_color_palette_4_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_4_t;

#define WINC_COLOR_PALETTE_5_OFFSET 0x505
#define WINC_B_COLOR_PALETTE_5_RESET  0x00000000
typedef union winc_b_color_palette_5_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_5_t;

#define WINC_COLOR_PALETTE_6_OFFSET 0x506
#define WINC_B_COLOR_PALETTE_6_RESET  0x00000000
typedef union winc_b_color_palette_6_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_6_t;

#define WINC_COLOR_PALETTE_7_OFFSET 0x507
#define WINC_B_COLOR_PALETTE_7_RESET  0x00000000
typedef union winc_b_color_palette_7_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_7_t;

#define WINC_COLOR_PALETTE_8_OFFSET 0x508
#define WINC_B_COLOR_PALETTE_8_RESET  0x00000000
typedef union winc_b_color_palette_8_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_8_t;

#define WINC_COLOR_PALETTE_9_OFFSET 0x509
#define WINC_B_COLOR_PALETTE_9_RESET  0x00000000
typedef union winc_b_color_palette_9_u {
    struct {
        unsigned int color_palette_r:8;     /* Red Color Palette */
        unsigned int color_palette_g:8;     /* Green Color Palette */
        unsigned int color_palette_b:8;     /* Blue Color Palette */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} winc_b_color_palette_9_t;

#endif // TEGRA_DC_H
